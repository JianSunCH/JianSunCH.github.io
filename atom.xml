<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙健的博客</title>
  
  <subtitle>Audi-Duckweed</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jiansunch.github.io/"/>
  <updated>2019-04-22T11:00:30.488Z</updated>
  <id>https://jiansunch.github.io/</id>
  
  <author>
    <name>Jian Sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>B1001 害死人不偿命的(3n+1)猜想</title>
    <link href="https://jiansunch.github.io/2019/04/22/B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3/"/>
    <id>https://jiansunch.github.io/2019/04/22/B1001-害死人不偿命的-3n-1-猜想/</id>
    <published>2019-04-22T10:35:37.000Z</published>
    <updated>2019-04-22T11:00:30.488Z</updated>
    
    <content type="html"><![CDATA[<h2>1001 害死人不偿命的(3n+1)猜想</h2><blockquote><p>卡拉兹(Callatz)猜想：对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？</p></blockquote><h3>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 n 的值。</p><h3>输出格式：</h3><p>输出从 n 计算到 1 需要的步数。</p><h3>输入样例：</h3><p><code>3</code></p><h3>输出样例：</h3><p><code>5</code></p><h3>解答</h3><pre class="line-numbers language-language-c++"><code class="language-language-c++">#include <cstdio>int main(){    int n, step = 0;    scanf("%d", &n);    while (n != 1)    {        if (n % 2 == 0)        {            n /= 2;        }        else        {            n = (3 * n + 1) / 2;        }        step++;    }    printf("%d\n", step);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1001 害死人不偿命的(3n+1)猜想&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;卡拉兹(Callatz)猜想：
对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="PAT" scheme="https://jiansunch.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT_Solution</title>
    <link href="https://jiansunch.github.io/2019/04/22/PAT-Solution/"/>
    <id>https://jiansunch.github.io/2019/04/22/PAT-Solution/</id>
    <published>2019-04-22T10:22:06.000Z</published>
    <updated>2019-04-22T11:03:51.683Z</updated>
    
    <content type="html"><![CDATA[<h1>PAT解答</h1><h2>Top Level</h2><table><thead><tr><th style="text-align:center">标号</th><th style="text-align:center">标题</th><th style="text-align:center">地址</th></tr></thead><tbody><tr><td style="text-align:center">A1002</td><td style="text-align:center">A+B for Polynomials</td><td style="text-align:center"><a href>C++</a></td></tr></tbody></table><h2>Basic Level</h2><table><thead><tr><th style="text-align:center">标号</th><th style="text-align:center">标题</th><th style="text-align:center">地址</th></tr></thead><tbody><tr><td style="text-align:center">B1001</td><td style="text-align:center">害死人不偿命的(3n+1)猜想</td><td style="text-align:center"><a href="/2019/04/22/B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3/">C++</a></td></tr><tr><td style="text-align:center">B1032</td><td style="text-align:center">挖掘机技术哪家强</td><td style="text-align:center"><a href>C++</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;PAT解答&lt;/h1&gt;
&lt;h2&gt;Top Level&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;标号&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;标题&lt;/th&gt;
&lt;th style
      
    
    </summary>
    
      <category term="题集" scheme="https://jiansunch.github.io/categories/%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="https://jiansunch.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>百钱白鸡</title>
    <link href="https://jiansunch.github.io/2019/04/16/%E7%99%BE%E9%92%B1%E7%99%BD%E9%B8%A1/"/>
    <id>https://jiansunch.github.io/2019/04/16/百钱白鸡/</id>
    <published>2019-04-16T15:44:26.000Z</published>
    <updated>2019-04-21T09:35:43.954Z</updated>
    
    <content type="html"><![CDATA[<h1>百钱白鸡</h1><h2>题目描述</h2><blockquote><p>鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一. 百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何—— 张丘建《算经》</p></blockquote><h2>求解方法</h2><ul><li>先构造可能的解的集合S={(X,Y,Z)|0&lt;=X,Y,Z&lt;=100} X, Y, Z分别代表买公鸡, 母鸡和小鸡的只数</li><li>然后验证条件X+Y+Z=100, 5X+3Y+Z/3=100</li><li>复杂度: O(100^2)</li></ul><h2>code</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>#include <time.h>clock_t start, stop;double duration;#define MAXN 10#define MAXK 1e7#define CLK_TCK 18.2int main(){    start = clock(); //开始计时    int z;    for (int x = 0; x <= 100; x++)    {        for (int y = 0; y <= 100 - x; y++)        {            z = 100 - x - y;            if (z % 3 == 0 && 5 * x + 3 * y + z / 3 == 100)            {                printf("x=%d, y=%d, z=%d\n", x, y, z);            }        }    }    stop = clock(); //停止计时    printf("ticks1 = %f\n", (double)(stop - start));    printf("duration1 = %6.2e\n", duration);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;百钱白鸡&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一. 百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何
—— 张丘建《算经》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;求解方法&lt;/h2&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="algo_base" scheme="https://jiansunch.github.io/tags/algo-base/"/>
    
  </entry>
  
  <entry>
    <title>A+B</title>
    <link href="https://jiansunch.github.io/2019/04/11/A-B/"/>
    <id>https://jiansunch.github.io/2019/04/11/A-B/</id>
    <published>2019-04-11T15:51:44.000Z</published>
    <updated>2019-04-16T15:45:49.274Z</updated>
    
    <content type="html"><![CDATA[<h1>A+B 输入输出练习I</h1><h2>题目描述</h2><p>你的任务是计算a+b。这是为了acm初学者专门设计的题目。你肯定发现还有其他题目跟这道题的标题类似，这些问题也都是专门为初学者提供的。</p><h2>输入</h2><p>输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。</p><h2>输出</h2><p>对于输入的每对a和b，你需要依次输出a、b的和。</p><p>如对于输入中的第二对a和b，在输出中它们的和应该也在第二行。</p><h2>样例输入</h2><p><code>1 5</code><code>10 20</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b;    while(scanf("%d%d", &a, &b) != EOF){        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。</p><h2>输出</h2><p>对于输入的每对a和b，你需要在相应的行输出a、b的和。如第二对a和b，对应的和也输出在第二行。</p><h2>样例输入</h2><p><code>2</code><code>1 5</code><code>10 20</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b, N;    scanf("%d", &N);    while (N--)    {        scanf("%d%d", &a, &b);        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>输入中每行是一对a和b。其中会有一对是0和0标志着输入结束，且这一对不要计算。</p><h2>输出</h2><p>对于输入的每对a和b，你需要在相应的行输出a、b的和。</p><p>如第二对a和b，他们的和也输出在第二行。</p><h2>样例输入</h2><p><code>1 5</code><code>10 20</code><code>0 0</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b;    while (scanf("%d%d", &a, &b), a || b)    {        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>输入的第一行为一个整数N，接下来N行每行先输入一个整数M，然后在同一行内输入M个整数。</p><h2>输出</h2><p>对于每组输入，输出M个数的和，每组输出之间输出一个空行。</p><h2>样例输入</h2><p><code>3</code><code>4 1 2 3 4</code><code>5 1 2 3 4 5</code><code>3 1 2 3</code></p><h2>样例输出</h2><p><code>10</code><code></code><code>15</code><code></code><code>6</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b, N, M, num;    scanf("%d", &N);    while (N--)    {        int sum = 0;        scanf("%d", &M);        for (int i = 0; i < M; i++)        {            scanf("%d", &num);            sum += num;        }        printf("%d\n", sum);        if (N > 0)        {            printf("\n");        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;A+B 输入输出练习I&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;你的任务是计算a+b。这是为了acm初学者专门设计的题目。你肯定发现还有其他题目跟这道题的标题类似，这些问题也都是专门为初学者提供的。&lt;/p&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;p&gt;输入包含一系列的a和b对，通过
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>6-12 解密</title>
    <link href="https://jiansunch.github.io/2019/04/03/6-12-%E8%A7%A3%E5%AF%86/"/>
    <id>https://jiansunch.github.io/2019/04/03/6-12-解密/</id>
    <published>2019-04-03T15:09:05.000Z</published>
    <updated>2019-04-03T15:17:44.675Z</updated>
    
    <content type="html"><![CDATA[<h1>习题6-12 解密</h1><h2>题目描述</h2><p>有一行电文，已按如下规律译成密码：</p><p>A--&gt;Z        a--&gt;z</p><p>B--&gt;Y        b--&gt;y</p><p>C--&gt;X        c--&gt;x</p><p>......          ......</p><p>即第一个字母变成第26个字母，第i个字母变成第（26-i+1)个字母，非字母字符不变。要求根据密码译回原文，并输出。</p><h2>输入</h2><p>输入一行密文</p><h2>输出</h2><p>解密后的原文，单独占一行。</p><h2>样例输入</h2><p><code>ZYX123zyx</code></p><h2>样例输出</h2><p><code>ABC123abc</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    char pass[100] = {};    gets(pass);    for (int i = 0; i < 100; i++)    {        if (pass[i] >= 'a' && pass[i] <= 'z')        {            pass[i] = 'a' + 'z' - pass[i];        }        else if (pass[i] >= 'A' && pass[i] <= 'Z')        {            pass[i] = 'A' + 'Z' - pass[i];        }    }    puts(pass);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;习题6-12 解密&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有一行电文，已按如下规律译成密码：&lt;/p&gt;
&lt;p&gt;A--&amp;gt;Z        a--&amp;gt;z&lt;/p&gt;
&lt;p&gt;B--&amp;gt;Y        b--&amp;gt;y&lt;/p&gt;
&lt;p&gt;C--&amp;gt;X       
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>6-6 杨辉三角</title>
    <link href="https://jiansunch.github.io/2019/04/03/6-6-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>https://jiansunch.github.io/2019/04/03/6-6-杨辉三角/</id>
    <published>2019-04-03T15:08:24.000Z</published>
    <updated>2019-04-03T15:17:41.717Z</updated>
    
    <content type="html"><![CDATA[<h1>习题6-6 杨辉三角</h1><h2>题目描述</h2><p>按要求输入如下格式的杨辉三角</p><p>11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1</p><p>最多输出10层</p><h2>输入</h2><p>输入只包含一个正整数n，表示将要输出的杨辉三角的层数。</p><h2>输出</h2><p>对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开</p><h2>样例输入</h2><p><code>5</code></p><h2>样例输出</h2><p><code>1</code><code>1 1</code><code>1 2 1</code><code>1 3 3 1</code><code>1 4 6 4 1</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int n;    scanf("%d", &n);    int a[n][n];    if (n <= 10)    {        for (int i = 0; i < n; i++)        {            for (int j = 0; j <= i; j++)            {                if (j == 0 || j == i)                {                    a[i][j] = 1;                }                //该元素的值等于正上方和左上方元素的和                else                {                    a[i][j] = a[i - 1][j] + a[i - 1][j - 1];                }                printf("%d ", a[i][j]);            }            printf("\n");        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;习题6-6 杨辉三角&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;按要求输入如下格式的杨辉三角&lt;/p&gt;
&lt;p&gt;1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1&lt;/p&gt;
&lt;p&gt;最多输出10层&lt;/p&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;p&gt;输入只
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>6-4 有序插入</title>
    <link href="https://jiansunch.github.io/2019/04/03/6-4-%E6%9C%89%E5%BA%8F%E6%8F%92%E5%85%A5/"/>
    <id>https://jiansunch.github.io/2019/04/03/6-4-有序插入/</id>
    <published>2019-04-03T15:06:49.000Z</published>
    <updated>2019-04-03T15:07:55.954Z</updated>
    
    <content type="html"><![CDATA[<h1>习题6-4 有序插入</h1><h2>题目描述</h2><p>有一个已排好序的数组，要求输入一个数后，按原来排序的规律将它插入到数组中。</p><p>假设数组长度为10，数组中前9个数（这9个数要求从键盘上输入，输入时要满足自小到大的输入顺序）已经按从小到大进行排序。</p><p>然后再从键盘上输入一个整数，将此整数插入到前有序的9个数中，使得最终的10个数依然是从小到大有序的。</p><h2>输入</h2><p>第一行输入以空格分隔的9个整数数，要求按从小到大的顺序输入。</p><p>第二行输入一个整数</p><h2>输出</h2><p>从小到大输出这10个数，每个数一行。</p><h2>样例输入</h2><p><code>1 11 21 31 41 51 61 71 81</code><code>45</code></p><h2>样例输出</h2><p><code>1 11 21 31 41 45 51 61 71 81</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a[10] = {0};    for (int i = 0; i < 9; i++)    {        scanf("%d", &a[i]);    }    scanf("%d", &a[9]);    //采用冒泡排序    //趟数 n - 1    for (int i = 1; i <= 9; i++)    {        //比较次数 n - i        for (int j = 0; j < 10 - i; j++)        {            if (a[j] > a[j + 1])            {                int temp = a[j];                a[j] = a[j + 1];                a[j + 1] = temp;            }        }    }    for (int i = 0; i < 10; i++)    {        printf("%d ", a[i]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;习题6-4 有序插入&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有一个已排好序的数组，要求输入一个数后，按原来排序的规律将它插入到数组中。&lt;/p&gt;
&lt;p&gt;假设数组长度为10，数组中前9个数（这9个数要求从键盘上输入，输入时要满足自小到大的输入顺序）已经按从小到大进行排序
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>4-1 一元二次方程求根</title>
    <link href="https://jiansunch.github.io/2019/04/03/4-1-%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9/"/>
    <id>https://jiansunch.github.io/2019/04/03/4-1-一元二次方程求根/</id>
    <published>2019-04-03T02:45:23.000Z</published>
    <updated>2019-04-03T15:10:08.956Z</updated>
    
    <content type="html"><![CDATA[<h1>例题4-1 一元二次方程求根</h1><h2>题目描述</h2><p>求一元二次方程ax2+bx+c=0的根，三个系数a, b, c由键盘输入，且a不能为0，但不保证b2-4ac&gt;0。</p><p>程序中所涉及的变量均为double类型。</p><h2>输入</h2><p>以空格分隔的一元二次方程的三个系数，双精度double类型</p><h2>输出</h2><p>分行输出两个根如下（注意末尾的换行）：</p><p>r1=第一个根</p><p>r2=第二个根</p><p>结果输出时，宽度占7位，其中小数部分2位。</p><p>如果方程无实根，输出一行如下信息（注意末尾的换行）：</p><p>No real roots!</p><h2>样例输入</h2><p><code>1 2 3</code></p><h2>样例输出</h2><p><code>No real roots!</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>#include <cmath>int main(){    double a, b, c;    double r1, r2;    scanf("%lf%lf%lf", &a, &b, &c);    if (a)    {        if (pow(b, 2) < 4 * a * c)        {            printf("No real roots!");        }        else        {            r1 = (-b + sqrt(pow(b, 2) - 4 * a * c)) / 2 * a;            r2 = (-b - sqrt(pow(b, 2) - 4 * a * c)) / 2 * a;            printf("r1=%f\nr2=%f", r1, r2);        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;例题4-1 一元二次方程求根&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;求一元二次方程ax2+bx+c=0的根，三个系数a, b, c由键盘输入，且a不能为0，但不保证b2-4ac&amp;gt;0。&lt;/p&gt;
&lt;p&gt;程序中所涉及的变量均为double类型。&lt;/p&gt;
&lt;h2&gt;输入
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>5-10 分数序列求和</title>
    <link href="https://jiansunch.github.io/2019/04/03/5-10-%E5%88%86%E6%95%B0%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/"/>
    <id>https://jiansunch.github.io/2019/04/03/5-10-分数序列求和/</id>
    <published>2019-04-02T16:16:35.000Z</published>
    <updated>2019-04-03T03:28:52.052Z</updated>
    
    <content type="html"><![CDATA[<h1>习题5-10 分数序列求和</h1><h2>题目描述</h2><p>有如下分数序列有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前 20 项之和</p><p>求出次数列的前20项之和。</p><p>请将结果的数据类型定义为double类型。</p><h2>输入</h2><p>无</p><h2>输出</h2><p>小数点后保留6位小数，末尾输出换行。</p><h2>样例输入</h2><p><code>无</code></p><h2>样例输出</h2><p><code>32.660261</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    //element分子，denominator分母    double denominator = 1, element = 2, temp;    double sum = 0;    for(int i = 1; i <= 20; i++)    {        sum += element / denominator;        temp = denominator;        //修改分母前，先保存分母        denominator = element;        element = temp + element;    }    printf("%.6f\n", sum);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;习题5-10 分数序列求和&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有如下分数序列
有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前 20 项之和&lt;/p&gt;
&lt;p&gt;求出次数列的前20项之和。&lt;/p&gt;
&lt;p&gt;请将结果的数据类型定义为do
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>5-8 Fibonacci数列</title>
    <link href="https://jiansunch.github.io/2019/04/03/5-8-Fibonacci%E6%95%B0%E5%88%97/"/>
    <id>https://jiansunch.github.io/2019/04/03/5-8-Fibonacci数列/</id>
    <published>2019-04-02T16:13:40.000Z</published>
    <updated>2019-04-03T03:28:23.154Z</updated>
    
    <content type="html"><![CDATA[<h1>例题5-8 Fibonacci数列</h1><h2>题目描述</h2><p>输入一个正整数n，求Fibonacci数列的第n个数。Fibonacci数列的特点：第1,2个数为1,1。从第3个数开始，概述是前面两个数之和。即：</p><p>要求输入的正整数n不超过50.</p><h2>输入</h2><p>一个不超过50的正整数</p><h2>输出</h2><p>Fibonacci数列的第n个数，末尾输出换行。</p><h2>样例输入</h2><p><code>20</code></p><h2>样例输出</h2><p><code>6765</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int Fibonacci(int n){    if (n == 0)    {        return 0;    }    else if (n == 1)    {        return 1;    }    else    {        return Fibonacci(n - 1) + Fibonacci(n - 2);    }}int main(){    int n;    scanf("%d", &n);    if (n <= 50)    {        printf("%d", Fibonacci(n));    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;例题5-8 Fibonacci数列&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;输入一个正整数n，求Fibonacci数列的第n个数。Fibonacci数列的特点：第1,2个数为1,1。从第3个数开始，概述是前面两个数之和。即：&lt;/p&gt;
&lt;p&gt;要求输入的正整数n不超过50
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>5-7 求圆周率pi的近似值</title>
    <link href="https://jiansunch.github.io/2019/04/02/5-7-%E6%B1%82%E5%9C%86%E5%91%A8%E7%8E%87pi%E7%9A%84%E8%BF%91%E4%BC%BC%E5%80%BC/"/>
    <id>https://jiansunch.github.io/2019/04/02/5-7-求圆周率pi的近似值/</id>
    <published>2019-04-01T16:04:23.000Z</published>
    <updated>2019-04-06T13:19:02.279Z</updated>
    
    <content type="html"><![CDATA[<h1>例题5-7 求圆周率pi的近似值</h1><h2>题目描述</h2><p>用如下公式</p><p><img src="http://ppe54uht5.bkt.clouddn.com/20181015224602644.png" alt="avatar"></p><p>求圆周率PI的近似值，直到发现某一项的绝对值小于10-6为止（该项不累加）。</p><p>要求输出的结果总宽度占10位，其中小数部分为8位。</p><p>程序中使用浮点型数据时，请定义为双精度double类型。</p><p>如果需要计算绝对值，可以使用C语言数学库提供的函数fabs，如求x的绝对值，则为fabs(x).</p><h2>输入</h2><p>无</p><h2>输出</h2><p>PI=圆周率的近似值</p><p>输出的结果总宽度占10位，其中小数部分为8位。</p><p>末尾输出换行。</p><h2>样例输入</h2><p><code>无</code></p><h2>样例输出</h2><p><code>PI=3.14159065</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>#include <cmath>int main(){    double sum = 0.0;    int sign = 1;    for (double i = 1; fabs(sign / i) > pow(10, -6); i = i + 2)    {        sum += sign / i;        sign = -sign;    }    printf("PI=%10.8f", 4 * sum);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;例题5-7 求圆周率pi的近似值&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;用如下公式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ppe54uht5.bkt.clouddn.com/20181015224602644.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>5-6 矩阵输出</title>
    <link href="https://jiansunch.github.io/2019/03/31/5-6-%E7%9F%A9%E9%98%B5%E8%BE%93%E5%87%BA/"/>
    <id>https://jiansunch.github.io/2019/03/31/5-6-矩阵输出/</id>
    <published>2019-03-31T09:34:35.000Z</published>
    <updated>2019-04-22T10:23:36.997Z</updated>
    
    <content type="html"><![CDATA[<h1>例题5-6 矩阵输出</h1><h2>题目描述</h2><p>输出以下4*5的矩阵</p><p>1  2  3  4  5</p><p>2  4  6  8 10</p><p>3  6  9 12 15</p><p>4  8 12 16 20</p><p>要求使用循环实现，注意每行输出5个数字，每个数字占3个字符的宽度，右对齐。</p><h2>输入</h2><p>无</p><h2>输出</h2><p>每行输出5个数字，每个数字占3个字符的宽度，右对齐。</p><h2>样例输入</h2><p><code>无</code></p><h2>样例输出</h2><p><code>1 2 3 4 5</code></p><p><code>2 4 6 8 10</code></p><p><code>3 6 9 12 15</code></p><p><code>4 8 12 16 20</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int n = 1;    for (int i = 0; i < 4; i++)    {        for (int j = 0; j < 5; j++)        {            printf("%3d", n++ * (i + 1));        }        n = 1;        printf("\n");    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;例题5-6 矩阵输出&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;输出以下4*5的矩阵&lt;/p&gt;
&lt;p&gt;1  2  3  4  5&lt;/p&gt;
&lt;p&gt;2  4  6  8 10&lt;/p&gt;
&lt;p&gt;3  6  9 12 15&lt;/p&gt;
&lt;p&gt;4  8 12 16 20&lt;/p&gt;
&lt;p&gt;要
      
    
    </summary>
    
      <category term="code" scheme="https://jiansunch.github.io/categories/code/"/>
    
    
      <category term="codeup" scheme="https://jiansunch.github.io/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>create</title>
    <link href="https://jiansunch.github.io/2019/03/31/create/"/>
    <id>https://jiansunch.github.io/2019/03/31/create/</id>
    <published>2019-03-31T06:02:26.000Z</published>
    <updated>2019-04-03T15:13:31.541Z</updated>
    
    <content type="html"><![CDATA[<h1>Hello World!</h1><h2>创建成功 :)</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;h2&gt;创建成功 :)&lt;/h2&gt;

      
    
    </summary>
    
      <category term="other category" scheme="https://jiansunch.github.io/categories/other-category/"/>
    
    
      <category term="hello" scheme="https://jiansunch.github.io/tags/hello/"/>
    
  </entry>
  
</feed>
