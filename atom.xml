<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙健的博客</title>
  
  <subtitle>Audi-Duckweed</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.jiansunch.com/"/>
  <updated>2019-04-28T09:32:47.887Z</updated>
  <id>https://www.jiansunch.com/</id>
  
  <author>
    <name>Jian Sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A1036 Boys vs Girls</title>
    <link href="https://www.jiansunch.com/PAT/A1036-Boys-vs-Girls/"/>
    <id>https://www.jiansunch.com/PAT/A1036-Boys-vs-Girls/</id>
    <published>2019-04-28T09:30:19.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>A1011 World Cup Betting</title>
    <link href="https://www.jiansunch.com/PAT/A1011-World-Cup-Betting/"/>
    <id>https://www.jiansunch.com/PAT/A1011-World-Cup-Betting/</id>
    <published>2019-04-28T09:29:17.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>A1006 Sign In and Sign Out</title>
    <link href="https://www.jiansunch.com/PAT/A1006-Sign-In-and-Sign-Out/"/>
    <id>https://www.jiansunch.com/PAT/A1006-Sign-In-and-Sign-Out/</id>
    <published>2019-04-28T09:28:21.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B1041 考试座位号</title>
    <link href="https://www.jiansunch.com/PAT/B1041-%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7/"/>
    <id>https://www.jiansunch.com/PAT/B1041-考试座位号/</id>
    <published>2019-04-28T09:26:55.000Z</published>
    <updated>2019-04-28T09:32:47.888Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B1028 人口普查</title>
    <link href="https://www.jiansunch.com/PAT/B1028-%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5/"/>
    <id>https://www.jiansunch.com/PAT/B1028-人口普查/</id>
    <published>2019-04-28T09:25:45.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>B1004 成绩排名</title>
    <link href="https://www.jiansunch.com/PAT/B1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D/"/>
    <id>https://www.jiansunch.com/PAT/B1004-成绩排名/</id>
    <published>2019-04-28T09:24:34.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>A1009 Product of Polynomials</title>
    <link href="https://www.jiansunch.com/PAT/A1009-Product-of-Polynomials/"/>
    <id>https://www.jiansunch.com/PAT/A1009-Product-of-Polynomials/</id>
    <published>2019-04-27T10:25:19.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>1009 Product of Polynomials</h2><blockquote><p>This time, you are supposed to find A×B where A and B are two polynomials.</p></blockquote><h3>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p>K N​1​​ a​N​1​​​​ N​2​​ a​N​2​​​​ ... N​K​​ a​N​K​​​​</p><p>where K is the number of nonzero terms in the polynomial, N​i​​ and a​N​i​​​​ (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10, 0≤N​K​​&lt;⋯&lt;N​2​​&lt;N​1​​≤1000.</p><h3>Output Specification:</h3><p>For each test case you should output the product of A and B in one line, with the same format as the input. Notice that there must be <strong>NO</strong> extra space at the end of each line. Please be accurate up to 1 decimal place.</p><h3>Sample Input:</h3><pre><code>2 1 2.4 0 3.22 2 1.5 1 0.5</code></pre><h3>Sample Output:</h3><pre><code>3 3 3.6 2 6.0 1 1.6</code></pre><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>const int max_n = 2001;double arr[max_n] = {0}; //存放最终结果struct Poly{int exp;  //指数double coeff; //系数} poly[1001]; //第一个多项式int main(){int K1, K2; //第一，二个多项式非零项的项数int exponents; //指数double coefficients; //系数//读入第一个多项式scanf("%d", &K1);for (int i = 0; i < K1; i++){scanf("%d%lf", &poly[i].exp, &poly[i].coeff);}//读入第二个多项式scanf("%d", &K2);for (int i = 0; i < K2; i++){scanf("%d%lf", &exponents, &coefficients);//与第一个多项式相乘//系数相乘,指数相加for (int j = 0; j < K1; j++){arr[exponents + poly[j].exp] += (coefficients * poly[j].coeff);}}//计算非零系数项的个数int count = 0;for (int i = 0; i < max_n; i++){if (arr[i] != 0)count++;}//输出多项式printf("%d", count);for (int i = max_n; i >= 0; i--){if (arr[i] != 0)printf(" %d %.1lf", i, arr[i]);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1009 Product of Polynomials&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This time, you are supposed to find A×B where A and B are two polynomials.&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>A1002 A+B for Polynomials</title>
    <link href="https://www.jiansunch.com/PAT/A1002-A-B-for-Polynomials/"/>
    <id>https://www.jiansunch.com/PAT/A1002-A-B-for-Polynomials/</id>
    <published>2019-04-27T10:24:57.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>1002 A+B for Polynomials</h2><blockquote><p>This time, you are supposed to find A+B where A and B are two polynomials.</p></blockquote><h3>Input Specification:</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:</p><p>K N​1​​ a​N​1​​​​ N​2​​ a​N​2​​​​ ... N​K​​ a​N​K​​​​</p><p>where K is the number of nonzero terms in the polynomial, N​i​​ and a​N​i​​​​ (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤N​K​​&lt;⋯&lt;N​2​​&lt;N​1​​≤1000.</p><h3>Output Specification:</h3><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p><h3>Sample Input:</h3><pre><code>2 1 2.4 0 3.22 2 1.5 1 0.5</code></pre><h3>Sample Output:</h3><pre><code>3 2 1.5 1 2.9 0 3.2</code></pre><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>const int max_n = 1001;double arr[max_n] = {0};int main(){int K;  //非零项的项数double coefficients; //系数int exponents; //指数//读入第一个多项式scanf("%d", &K);for (int i = 0; i < K; i++){scanf("%d%lf", &exponents, &coefficients);arr[exponents] += coefficients;}//读入第二个多项式scanf("%d", &K);for (int i = 0; i < K; i++){scanf("%d%lf", &coefficients, &exponents);arr[coefficients] += exponents;}//计算非零系数项的个数int count = 0;for (int i = 0; i < max_n; i++){if (arr[i] != 0)count++;}//输出多项式printf("%d", count);for (int i = max_n; i >= 0; i--){if (arr[i] != 0)printf(" %d %.1lf", i, arr[i]);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1002 A+B for Polynomials&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;This time, you are supposed to find A+B where A and B are two polynomials.&lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1010 一元多项式求导</title>
    <link href="https://www.jiansunch.com/PAT/B1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/"/>
    <id>https://www.jiansunch.com/PAT/B1010-一元多项式求导/</id>
    <published>2019-04-26T10:26:09.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>010 一元多项式求导</h2><blockquote><p>设计函数求一元多项式的导数。（注：(\boldsymbol{x}^{n})（n为整数）的一阶导数为(\boldsymbol{n} \boldsymbol{x}^{n-1}))。</p></blockquote><h3>输入格式:</h3><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p><h3>输出格式:</h3><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p><h3>输入样例:</h3><pre><code>3 4 -5 2 6 1 -2 0 </code></pre><h3>输出样例:</h3><pre><code>12 3 -10 1 6 0</code></pre><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int a[1001] = {0};//k为系数,e为指数int k, e;while (scanf("%d%d", &k, &e) != EOF){a[e] = k;}//常数求导直接为0a[0] = 0;int count = 0;//从低到高枚举for (int i = 1; i <= 1000; i++){//求导公式a[i - 1] = a[i] * i;a[i] = 0;//指数不为0的个数if (a[i - 1] != 0)count++;}//零多项式if (count == 0){printf("0 0");}else{//从高到低输出for (int i = 1000; i >= 0; i--){if (a[i] != 0){printf("%d %d", a[i], i);count--;if (count != 0)printf(" ");}}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;010 一元多项式求导&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;设计函数求一元多项式的导数。（注：(\boldsymbol{x}^{n})（n为整数）的一阶导数为(\boldsymbol{n} \boldsymbol{x}^{n-1}))。&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>A1065 A+B and C (64bit)</title>
    <link href="https://www.jiansunch.com/PAT/A1065-A-B-and-C-64bit/"/>
    <id>https://www.jiansunch.com/PAT/A1065-A-B-and-C-64bit/</id>
    <published>2019-04-26T02:22:32.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>1065 A+B and C (64bit)</h2><p>Given three integers A, B and C in [−2​^63​​,2​^63​​], you are supposed to tell whether A+B&gt;C.</p><h3>Input Specification:</h3><p>The first line of the input gives the positive number of test cases, T (≤10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces.</p><h3>Output Specification:</h3><p>For each test case, output in one line <code>Case #X: true</code> if A+B&gt;C, or <code>Case #X: false</code> otherwise, where X is the case number (starting from 1).</p><h3>Sample Input:</h3><pre><code>31 2 3 2 3 49223372036854775807 -9223372036854775808 0 </code></pre><h3>Sample Output:</h3><pre><code>Case #1: false Case #2: true Case #3: false</code></pre><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int T, count = 1;scanf("%d", &T);long long A, B, C, result;while (T--){scanf("%lld%lld%lld", &A, &B, &C);result = A + B;bool flag;//正溢出if (A > 0 && B > 0 && result < 0)flag = true;//负溢出else if (A < 0 && B < 0 && result >= 0)flag = false;//没有溢出else if (result > C)flag = true;elseflag = false;if (flag == true)printf("Case #%d: true\n", count++);elseprintf("Case #%d: false\n", count++);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1065 A+B and C (64bit)&lt;/h2&gt;
&lt;p&gt;Given three integers A, B and C in [−2​^63​​,2​^63​​], you are supposed to tell whether A+B&amp;gt;C.&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>A1042 Shuffling Machine</title>
    <link href="https://www.jiansunch.com/PAT/A1042-Shuffling-Machine/"/>
    <id>https://www.jiansunch.com/PAT/A1042-Shuffling-Machine/</id>
    <published>2019-04-26T02:15:20.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>1042 Shuffling Machine</h2><blockquote><p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid &quot;inside jobs&quot; where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.</p></blockquote><blockquote><p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p></blockquote><pre><code>S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2</code></pre><blockquote><p>where &quot;S&quot; stands for &quot;Spade&quot;, &quot;H&quot; for &quot;Heart&quot;, &quot;C&quot; for &quot;Club&quot;, &quot;D&quot; for &quot;Diamond&quot;, and &quot;J&quot; for &quot;Joker&quot;. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p></blockquote><h3>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p><h3>Output Specification:</h3><p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p><h3>Sample Input:</h3><pre><code>236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</code></pre><h3>Sample Output:</h3><pre><code>S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</code></pre><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>const int N = 54;int main(){int K;scanf("%d", &K);char arr[5] = {'S', 'H', 'C', 'D', 'J'};int start[N + 1], end[N + 1], temp[N + 1]; //编号从1开始取,所以要加1//初始化牌编号，从1开始for (int i = 1; i <= N; i++){start[i] = i;}for (int i = 1; i <= N; i++){scanf("%d", &temp[i]);}for (int step = 0; step < K; step++){//存储到end数组对应的位置区for (int i = 1; i <= N; i++){end[temp[i]] = start[i];}//重新赋值给start数组for (int i = 1; i <= N; i++){start[i] = end[i];}}int count = 0;//按照要求输出,花色和编号的关系for (int i = 1; i <= N; i++){start[i]--;//减1,否则e.g. 13->0printf("%c%d", arr[start[i] / 13], start[i] % 13 + 1);count++;if (count < N)printf(" ");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1042 Shuffling Machine&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffli
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>A1046 Shortest Distance</title>
    <link href="https://www.jiansunch.com/PAT/A1046-Shortest-Distance/"/>
    <id>https://www.jiansunch.com/PAT/A1046-Shortest-Distance/</id>
    <published>2019-04-25T14:47:53.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>1046 Shortest Distance</h2><blockquote><p>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p></blockquote><h3>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer N (in [3,10​^5​​]), followed by N integer distances D​1​​ D​2​​ ⋯ D​N​​, where D​i​​ is the distance between the i-th and the (i+1)-st exits, and D​N​​ is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤10​4​​), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10​7​​.</p><h3>Output Specification:</h3><p>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.</p><h3>Sample Input:</h3><pre><code>5 1 2 4 14 931 32 54 1</code></pre><h3>Sample Output:</h3><pre><code>3107</code></pre><h3>解答</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <bits/stdc++.h>using namespace std;const int MAXN = 100001;//dis数组为1到i按顺时针方向的下一个节点的距离//cur数组为i到i+1的距离int dis[MAXN], cur[MAXN], sum = 0;int main(){int N;scanf("%d", &N);for (int i = 1; i <= N; i++){//输入i到i+1的距离scanf("%d", &cur[i]);//对dis数组进行预处理,以防超时sum += cur[i];dis[i] = sum;}int M, vertexA, vertexB;scanf("%d", &M);//查找最短路径for (int i = 1; i <= M; i++){scanf("%d%d", &vertexA, &vertexB);//vertexA > vertexB,交换if (vertexA > vertexB)swap(vertexA, vertexB);//vertexA到vertexB的距离int temp = dis[vertexB - 1] - dis[vertexA - 1];printf("%d\n", min(temp, sum - temp));}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1046 Shortest Distance&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The task is really simple: given N exits on a highway which forms a simple cycle, you are su
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1018 锤子剪刀布</title>
    <link href="https://www.jiansunch.com/PAT/B1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/"/>
    <id>https://www.jiansunch.com/PAT/B1018-锤子剪刀布/</id>
    <published>2019-04-25T09:55:50.000Z</published>
    <updated>2019-04-28T09:32:47.888Z</updated>
    
    <content type="html"><![CDATA[<h2>1018 锤子剪刀布</h2><blockquote><p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p></blockquote><p><img src="https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg" alt="FigCJB.jpg"></p><blockquote><p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p></blockquote><h3>输入格式：</h3><p>输入第 1 行给出正整数 N（≤10​5​​），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。<code>C</code> 代表“锤子”、<code>J</code> 代表“剪刀”、<code>B</code> 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。</p><h3>输出格式：</h3><p>输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。</p><h3>输入样例：</h3><p><code>10</code><code>C J</code><code>J B</code><code>C B</code><code>B B</code><code>B C</code><code>C C</code><code>C B</code><code>J B</code><code>B C</code><code>J J</code></p><h3>输出样例：</h3><p><code>5 3 2</code><code>2 3 5</code><code>B B</code></p><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>//字典序增序int change(char c){if (c == 'B')return 0;if (c == 'C')return 1;if (c == 'J')return 2;}int main(){int N;scanf("%d", &N);//甲乙的手势char a, b;char arr[3] = {'B', 'C', 'J'};//甲乙的输赢次数int infoA[3] = {0}, infoB[3] = {0};//甲乙手势的获胜次数int handA[3] = {0}, handB[3] = {0};int num1, num2;while (N--){//用来吸收空格,scanf会读入空格和换行符getchar();//要留有空格scanf("%c %c", &a, &b);//转换为数字num1 = change(a);num2 = change(b);//如果甲赢if ((num1 + 1) % 3 == num2){infoA[0]++;//甲赢的次数+1infoB[2]++;//乙输的次数+1handA[num1]++; //甲赢的手势次数+1}//如果乙赢else if ((num2 + 1) % 3 == num1){infoB[0]++;//乙赢的次数+1infoA[2]++;//甲输的次数+1handB[num2]++; //乙赢的手势次数+1}else{infoA[1]++; //甲平局的次数+1infoB[1]++; //乙平局的次数+1}}printf("%d %d %d\n", infoA[0], infoA[1], infoA[2]);printf("%d %d %d\n", infoB[0], infoB[1], infoB[2]);//甲乙手势的获胜次数最多的idint idA = 0, idB = 0;for (int i = 0; i < 3; i++){if (handA[i] > handA[idA])idA = i;if (handB[i] > handB[idB])idB = i;}printf("%c %c\n", arr[idA], arr[idB]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1018 锤子剪刀布&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images.ptausercontent.com/72
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1012 数字分类</title>
    <link href="https://www.jiansunch.com/PAT/B1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/"/>
    <id>https://www.jiansunch.com/PAT/B1012-数字分类/</id>
    <published>2019-04-24T15:45:54.000Z</published>
    <updated>2019-04-28T09:32:47.888Z</updated>
    
    <content type="html"><![CDATA[<h2>1012 数字分类</h2><blockquote><p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p></blockquote><ul><li>A​1​​ = 能被 5 整除的数字中所有偶数的和；</li><li>A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯；</li><li>A​3​​ = 被 5 除后余 2 的数字的个数；</li><li>A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；</li><li>A​5​​ = 被 5 除后余 4 的数字中最大数字。</li></ul><h3>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p><h3>输出格式：</h3><p>对给定的 N 个正整数，按题目要求计算 A​1​​~A​5​​ 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p><p>若其中某一类数字不存在，则在相应位置输出 <code>N</code>。</p><h3>输入样例 1：</h3><p><code>13 1 2 3 4 5 6 7 8 9 10 20 16 18</code></p><h3>输出样例 1：</h3><p><code>30 11 2 9.7 9</code></p><h3>输入样例 2：</h3><p><code>8 1 2 4 5 6 7 9 16</code></p><h3>输出样例 2：</h3><p><code>N 11 2 N 9</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int N, num;scanf("%d", &N);int arr[5] = {0};int count[5] = {0};for (int i = 0; i < N; i++){scanf("%d", &num);//A1if (num % 5 == 0){if (num % 2 == 0){arr[0] += num;count[0]++;}}//A2 转换为n1(0) + n3(2) - n2(1) - n4(3)...else if (num % 5 == 1){if (count[1] % 2 == 0){arr[1] += num;}else{arr[1] -= num;}count[1]++;}//A3else if (num % 5 == 2){count[2]++;}//A4else if (num % 5 == 3){arr[3] += num;count[3]++;}//A5else{if (num > arr[4]){arr[4] = num;}count[4]++;}}if (count[0] == 0)printf("N ");elseprintf("%d ", arr[0]);if (count[1] == 0)printf("N ");elseprintf("%d ", arr[1]);if (count[2] == 0)printf("N ");elseprintf("%d ", count[2]);if (count[3] == 0)printf("N ");elseprintf("%.1f ", (double)arr[3] / count[3]);if (count[4] == 0)printf("N");elseprintf("%d", arr[4]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1012 数字分类&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A​1​​ = 能被 5 整除的数字中所有偶数的和；&lt;/li&gt;
&lt;li&gt;A​2​​ = 
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1008 数组元素循环右移问题</title>
    <link href="https://www.jiansunch.com/PAT/B1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>https://www.jiansunch.com/PAT/B1008-数组元素循环右移问题/</id>
    <published>2019-04-24T15:18:40.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>1008 数组元素循环右移问题</h2><blockquote><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A​0​​A​1​​⋯A​N−1​​）变换为（A​N−M​​⋯A​N−1​​A​0​​A​1​​⋯A​N−M−1​​）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p></blockquote><h3>输入格式:</h3><p>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p><h3>输出格式:</h3><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><h3>输入样例:</h3><p><code>6 2</code><code>1 2 3 4 5 6</code></p><h3>输出样例:</h3><p><code>5 6 1 2 3 4</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int N, M;scanf("%d%d", &N, &M);//保证M < NM = M % N;int arr[N];for (int i = 0; i < N; i++){scanf("%d", &arr[i]);}//计数器，即已经打印了多少数int count = 0;//特殊情况,原样输出if (M == 0){for (int i = 0; i < N; i++){printf("%d", arr[i]);count++;if (count < N)printf(" ");}}else{count = 0;//输出N - M到N - 1for (int i = N - M; i <= N - 1; i++){printf("%d ", arr[i]);count++;}//输出0到N - M - 1for (int i = 0; i <= N - M - 1; i++){printf("%d", arr[i]);count++;if (count < N)printf(" ");}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1008 数组元素循环右移问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一个数组A中存有N（&amp;gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A​0​​A​1​​⋯A​N−1​​）变换为（A​N−M​​⋯A​N−1
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1046 划拳</title>
    <link href="https://www.jiansunch.com/PAT/B1046-%E5%88%92%E6%8B%B3/"/>
    <id>https://www.jiansunch.com/PAT/B1046-划拳/</id>
    <published>2019-04-24T11:03:05.000Z</published>
    <updated>2019-04-28T09:32:47.888Z</updated>
    
    <content type="html"><![CDATA[<h2>1046 划拳 （15 分)</h2><blockquote><p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。</p></blockquote><blockquote><p>下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。</p></blockquote><h3>输入格式：</h3><p>输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为：</p><p><code>甲喊 甲划 乙喊 乙划</code></p><p>其中<code>喊</code>是喊出的数字，<code>划</code>是划出的数字，均为不超过 100 的正整数（两只手一起划）。</p><h3>输出格式：</h3><p>在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。</p><h3>输入样例：</h3><p><code>5</code><code>8 10 9 12</code><code>5 10 5 10</code><code>3 8 5 12</code><code>12 18 1 13</code><code>4 16 12 15</code></p><h3>输出样例：</h3><p><code>1 2</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){//a1为甲喊的数,a2为甲比划的数,b1为乙喊的数,b2为乙比划的数//cupA为甲喝的杯数,cupB为乙喝的杯数int a1, a2, b1, b2, cupA = 0, cupB = 0;int N;scanf("%d", &N);while (N--){scanf("%d%d%d%d", &a1, &a2, &b1, &b2);//甲赢if (a1 + b1 == a2 && a1 + b1 != b2){cupB++;}//乙赢if (a1 + b1 == b2 && a1 + b1 != a2){cupA++;}}printf("%d %d\n", cupA, cupB);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1046 划拳 （15 分)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1026 程序运行时间</title>
    <link href="https://www.jiansunch.com/PAT/B1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
    <id>https://www.jiansunch.com/PAT/B1026-程序运行时间/</id>
    <published>2019-04-24T10:27:24.000Z</published>
    <updated>2019-04-28T09:32:47.888Z</updated>
    
    <content type="html"><![CDATA[<h2>1026 程序运行时间</h2><blockquote><p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。</p></blockquote><blockquote><p>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p></blockquote><h3>输入格式：</h3><p>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10​​^7]。</p><h3>输出格式：</h3><p>在一行中输出被测函数运行的时间。运行时间必须按照 <code>hh:mm:ss</code>（即2位的 <code>时:分:秒</code>）格式输出；不足 1 秒的时间四舍五入到秒。</p><h3>输入样例：</h3><p><code>123 4577973</code></p><h3>输出样例：</h3><p><code>12:42:59</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int C1, C2;scanf("%d%d", &C1, &C2);int seconds = C2 - C1; //运行的时间(单位为s)//四舍五入if (seconds % 100 >= 50){seconds = seconds / 100 + 1;}else{seconds = seconds / 100;}printf("%02d:%02d:%02d", seconds / 3600, seconds % 3600 / 60, seconds % 60);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1026 程序运行时间&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tic
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1016 部分A+B</title>
    <link href="https://www.jiansunch.com/PAT/B1016-%E9%83%A8%E5%88%86A-B/"/>
    <id>https://www.jiansunch.com/PAT/B1016-部分A-B/</id>
    <published>2019-04-23T15:56:06.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>1016 部分A+B （15 分)</h2><blockquote><p>正整数 A 的“D​A​​（为 1 位整数）部分”定义为由 A 中所有 D​A​​ 组成的新整数 P​A​​。例如：给定 A=3862767，D​A​​=6，则 A 的“6 部分”P​A​​ 是 66，因为 A 中有 2 个 6。</p></blockquote><blockquote><p>现给定 A、D​A​​、B、D​B​​，请编写程序计算 P​A​​+P​B​​。</p></blockquote><h3>输入格式：</h3><p>输入在一行中依次给出 A、D​A​​、B、D​B​​，中间以空格分隔，其中 0&lt;A,B&lt;10​^10​​。</p><h3>输出格式：</h3><p>在一行中输出 P​A​​+P​B​​ 的值。</p><h3>输入样例 1：</h3><p><code>3862767 6 13530293 3</code></p><h3>输出样例 1：</h3><p><code>399</code></p><h3>输入样例 2：</h3><p><code>3862767 1 13530293 8</code></p><h3>输出样例 2：</h3><p><code>0</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){long long A, Da, B, Db;scanf("%lld%lld%lld%lld", &A, &Da, &B, &Db);long long Pa = 0, Pb = 0;//检查A的每一位while (A != 0){if (A % 10 == Da)Pa = Pa * 10 + Da;A /= 10;}//检查B的每一位while (B != 0){if (B % 10 == Db)Pb = Pb * 10 + Db;B /= 10;}printf("%lld\n", Pa + Pb);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1016 部分A+B （15 分)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;正整数 A 的“D​A​​（为 1 位整数）部分”定义为由 A 中所有 D​A​​ 组成的新整数 P​A​​。例如：给定 A=3862767，D​A​​=6，则 A 的“6 部分”P​A​​ 是
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1011 A+B 和 C</title>
    <link href="https://www.jiansunch.com/PAT/B1011-A-B-%E5%92%8C-C/"/>
    <id>https://www.jiansunch.com/PAT/B1011-A-B-和-C/</id>
    <published>2019-04-23T15:21:29.000Z</published>
    <updated>2019-04-28T09:32:47.887Z</updated>
    
    <content type="html"><![CDATA[<h2>1011 A+B 和 C</h2><blockquote><p>给定区间 [−2​^31​​,2​^31​​] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。</p></blockquote><h3>输入格式：</h3><p>输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。</p><h3>输出格式：</h3><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 A+B&gt;C，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。</p><h3>输入样例：</h3><p><code>4</code><code>1 2 3</code><code>2 3 4</code><code>2147483647 0 2147483646</code><code>0 -2147483648 -2147483647</code></p><h3>输出样例：</h3><p><code>Case #1: false</code><code>Case #2: true</code><code>Case #3: true</code><code>Case #4: false</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int T, count = 1;scanf("%d", &T);long long A, B, C;//while版本while (T--){scanf("%lld%lld%lld", &A, &B, &C);if (A + B > C){printf("Case #%d: true\n", count++);}else{printf("Case #%d: false\n", count++);}}//for版本// for (int i = 1; i <= T; i++)// {// scanf("%lld%lld%lld", &A, &B, &C);// if (A + B > C)// {// printf("Case #%d: true\n", i);// }// else// {// printf("Case #%d: false\n", i);// }// }return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1011 A+B 和 C&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定区间 [−2​^31​​,2​^31​​] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;输入格式：&lt;/h3&gt;
&lt;p&gt;输入第 1 行给出
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1032 挖掘机技术哪家强</title>
    <link href="https://www.jiansunch.com/PAT/B1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA/"/>
    <id>https://www.jiansunch.com/PAT/B1032-挖掘机技术哪家强/</id>
    <published>2019-04-22T14:46:01.000Z</published>
    <updated>2019-04-28T09:32:47.888Z</updated>
    
    <content type="html"><![CDATA[<h2>1032 挖掘机技术哪家强</h2><blockquote><p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p></blockquote><h3>输入格式：</h3><p>输入在第 1 行给出不超过 10​5​​ 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p><h3>输出格式：</h3><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p><h3>输入样例：</h3><p><code>6</code><code>3 65</code><code>2 80</code><code>1 100</code><code>2 70</code><code>3 40</code><code>3 0</code></p><h3>输出样例：</h3><p><code>2 150</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main() {int N, schoolId, schoolScore;int school[100001] = {0};scanf("%d", &N);for(int i = 0; i < N; i++) {scanf("%d%d", &schoolId, &schoolScore);school[schoolId] += schoolScore;}int topId = 1, topScore = -1;for(int i = 1; i <= N; i++) {if(school[i] > topScore) {topScore = school[i];topId = i;}}printf("%d %d\n", topId, topScore);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1032 挖掘机技术哪家强&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;输入格式：&lt;/h3&gt;
&lt;p&gt;输入在第 1 
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
</feed>
