<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙健的博客</title>
  
  <subtitle>Audi-Duckweed</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.jiansunch.com/"/>
  <updated>2019-04-26T10:32:15.123Z</updated>
  <id>https://www.jiansunch.com/</id>
  
  <author>
    <name>Jian Sun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>B1010 一元多项式求导</title>
    <link href="https://www.jiansunch.com/B1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/"/>
    <id>https://www.jiansunch.com/B1010-一元多项式求导/</id>
    <published>2019-04-26T10:26:09.000Z</published>
    <updated>2019-04-26T10:32:15.123Z</updated>
    
    <content type="html"><![CDATA[<h2>010 一元多项式求导</h2><blockquote><p>设计函数求一元多项式的导数。（注：(\boldsymbol{x}^{n})（n为整数）的一阶导数为(\boldsymbol{n} \boldsymbol{x}^{n-1}))。</p></blockquote><h3>输入格式:</h3><p>以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔。</p><h3>输出格式:</h3><p>以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是 0，但是表示为 <code>0 0</code>。</p><h3>输入样例:</h3><pre><code>3 4 -5 2 6 1 -2 0 </code></pre><h3>输出样例:</h3><pre><code>12 3 -10 1 6 0</code></pre><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;010 一元多项式求导&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;设计函数求一元多项式的导数。（注：(\boldsymbol{x}^{n})（n为整数）的一阶导数为(\boldsymbol{n} \boldsymbol{x}^{n-1}))。&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>A1065 A+B and C (64bit)</title>
    <link href="https://www.jiansunch.com/A1065-A-B-and-C-64bit/"/>
    <id>https://www.jiansunch.com/A1065-A-B-and-C-64bit/</id>
    <published>2019-04-26T02:22:32.000Z</published>
    <updated>2019-04-26T10:20:49.903Z</updated>
    
    <content type="html"><![CDATA[<h2>1065 A+B and C (64bit)</h2><p>Given three integers A, B and C in [−2​^63​​,2​^63​​], you are supposed to tell whether A+B&gt;C.</p><h3>Input Specification:</h3><p>The first line of the input gives the positive number of test cases, T (≤10). Then T test cases follow, each consists of a single line containing three integers A, B and C, separated by single spaces.</p><h3>Output Specification:</h3><p>For each test case, output in one line <code>Case #X: true</code> if A+B&gt;C, or <code>Case #X: false</code> otherwise, where X is the case number (starting from 1).</p><h3>Sample Input:</h3><pre><code>31 2 3 2 3 49223372036854775807 -9223372036854775808 0 </code></pre><h3>Sample Output:</h3><pre><code>Case #1: false Case #2: true Case #3: false</code></pre><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int T, count = 1;scanf("%d", &T);long long A, B, C, result;while (T--){scanf("%lld%lld%lld", &A, &B, &C);result = A + B;bool flag;//正溢出if (A > 0 && B > 0 && result < 0)flag = true;//负溢出else if (A < 0 && B < 0 && result >= 0)flag = false;//没有溢出else if (result > C)flag = true;elseflag = false;if (flag == true)printf("Case #%d: true\n", count++);elseprintf("Case #%d: false\n", count++);}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1065 A+B and C (64bit)&lt;/h2&gt;
&lt;p&gt;Given three integers A, B and C in [−2​^63​​,2​^63​​], you are supposed to tell whether A+B&amp;gt;C.&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>A1042 Shuffling Machine</title>
    <link href="https://www.jiansunch.com/A1042-Shuffling-Machine/"/>
    <id>https://www.jiansunch.com/A1042-Shuffling-Machine/</id>
    <published>2019-04-26T02:15:20.000Z</published>
    <updated>2019-04-26T02:37:30.908Z</updated>
    
    <content type="html"><![CDATA[<h2>1042 Shuffling Machine</h2><blockquote><p>Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid &quot;inside jobs&quot; where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines. Your task is to simulate a shuffling machine.</p></blockquote><blockquote><p>The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order:</p></blockquote><pre><code>S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2</code></pre><blockquote><p>where &quot;S&quot; stands for &quot;Spade&quot;, &quot;H&quot; for &quot;Heart&quot;, &quot;C&quot; for &quot;Club&quot;, &quot;D&quot; for &quot;Diamond&quot;, and &quot;J&quot; for &quot;Joker&quot;. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13.</p></blockquote><h3>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer K (≤20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space.</p><h3>Output Specification:</h3><p>For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line.</p><h3>Sample Input:</h3><pre><code>236 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47</code></pre><h3>Sample Output:</h3><pre><code>S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5</code></pre><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>const int N = 54;int main(){int K;scanf("%d", &K);char arr[5] = {'S', 'H', 'C', 'D', 'J'};int start[N + 1], end[N + 1], temp[N + 1]; //编号从1开始取,所以要加1//初始化牌编号，从1开始for (int i = 1; i <= N; i++){start[i] = i;}for (int i = 1; i <= N; i++){scanf("%d", &temp[i]);}for (int step = 0; step < K; step++){//存储到end数组对应的位置区for (int i = 1; i <= N; i++){end[temp[i]] = start[i];}//重新赋值给start数组for (int i = 1; i <= N; i++){start[i] = end[i];}}int count = 0;//按照要求输出,花色和编号的关系for (int i = 1; i <= N; i++){start[i]--;//减1,否则e.g. 13->0printf("%c%d", arr[start[i] / 13], start[i] % 13 + 1);count++;if (count < N)printf(" ");}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1042 Shuffling Machine&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffli
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>A1046 Shortest Distance</title>
    <link href="https://www.jiansunch.com/A1046-Shortest-Distance/"/>
    <id>https://www.jiansunch.com/A1046-Shortest-Distance/</id>
    <published>2019-04-25T14:47:53.000Z</published>
    <updated>2019-04-26T09:26:48.711Z</updated>
    
    <content type="html"><![CDATA[<h2>1046 Shortest Distance</h2><blockquote><p>The task is really simple: given N exits on a highway which forms a simple cycle, you are supposed to tell the shortest distance between any pair of exits.</p></blockquote><h3>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains an integer N (in [3,10​^5​​]), followed by N integer distances D​1​​ D​2​​ ⋯ D​N​​, where D​i​​ is the distance between the i-th and the (i+1)-st exits, and D​N​​ is between the N-th and the 1st exits. All the numbers in a line are separated by a space. The second line gives a positive integer M (≤10​4​​), with M lines follow, each contains a pair of exit numbers, provided that the exits are numbered from 1 to N. It is guaranteed that the total round trip distance is no more than 10​7​​.</p><h3>Output Specification:</h3><p>For each test case, print your results in M lines, each contains the shortest distance between the corresponding given pair of exits.</p><h3>Sample Input:</h3><pre><code>5 1 2 4 14 931 32 54 1</code></pre><h3>Sample Output:</h3><pre><code>3107</code></pre><h3>解答</h3><pre class="line-numbers language-language-cpp"><code class="language-language-cpp">#include <bits/stdc++.h>using namespace std;const int MAXN = 100001;//dis数组为1到i按顺时针方向的下一个节点的距离//cur数组为i到i+1的距离int dis[MAXN], cur[MAXN], sum = 0;int main(){int N;scanf("%d", &N);for (int i = 1; i <= N; i++){//输入i到i+1的距离scanf("%d", &cur[i]);//对dis数组进行预处理,以防超时sum += cur[i];dis[i] = sum;}int M, vertexA, vertexB;scanf("%d", &M);//查找最短路径for (int i = 1; i <= M; i++){scanf("%d%d", &vertexA, &vertexB);//vertexA > vertexB,交换if (vertexA > vertexB)swap(vertexA, vertexB);//vertexA到vertexB的距离int temp = dis[vertexB - 1] - dis[vertexA - 1];printf("%d\n", min(temp, sum - temp));}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1046 Shortest Distance&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;The task is really simple: given N exits on a highway which forms a simple cycle, you are su
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1018 锤子剪刀布</title>
    <link href="https://www.jiansunch.com/B1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83/"/>
    <id>https://www.jiansunch.com/B1018-锤子剪刀布/</id>
    <published>2019-04-25T09:55:50.000Z</published>
    <updated>2019-04-26T09:44:00.337Z</updated>
    
    <content type="html"><![CDATA[<h2>1018 锤子剪刀布</h2><blockquote><p>大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：</p></blockquote><p><img src="https://images.ptausercontent.com/724da598-b37f-4f1f-99b4-71459654ce3a.jpg" alt="FigCJB.jpg"></p><blockquote><p>现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</p></blockquote><h3>输入格式：</h3><p>输入第 1 行给出正整数 N（≤10​5​​），即双方交锋的次数。随后 N 行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。<code>C</code> 代表“锤子”、<code>J</code> 代表“剪刀”、<code>B</code> 代表“布”，第 1 个字母代表甲方，第 2 个代表乙方，中间有 1 个空格。</p><h3>输出格式：</h3><p>输出第 1、2 行分别给出甲、乙的胜、平、负次数，数字间以 1 个空格分隔。第 3 行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有 1 个空格。如果解不唯一，则输出按字母序最小的解。</p><h3>输入样例：</h3><p><code>10</code><code>C J</code><code>J B</code><code>C B</code><code>B B</code><code>B C</code><code>C C</code><code>C B</code><code>J B</code><code>B C</code><code>J J</code></p><h3>输出样例：</h3><p><code>5 3 2</code><code>2 3 5</code><code>B B</code></p><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>//字典序增序int change(char c){if (c == 'B')return 0;if (c == 'C')return 1;if (c == 'J')return 2;}int main(){int N;scanf("%d", &N);//甲乙的手势char a, b;char arr[3] = {'B', 'C', 'J'};//甲乙的输赢次数int infoA[3] = {0}, infoB[3] = {0};//甲乙手势的获胜次数int handA[3] = {0}, handB[3] = {0};int num1, num2;while (N--){//用来吸收空格,scanf会读入空格和换行符getchar();//要留有空格scanf("%c %c", &a, &b);//转换为数字num1 = change(a);num2 = change(b);//如果甲赢if ((num1 + 1) % 3 == num2){infoA[0]++;//甲赢的次数+1infoB[2]++;//乙输的次数+1handA[num1]++; //甲赢的手势次数+1}//如果乙赢else if ((num2 + 1) % 3 == num1){infoB[0]++;//乙赢的次数+1infoA[2]++;//甲输的次数+1handB[num2]++; //乙赢的手势次数+1}else{infoA[1]++; //甲平局的次数+1infoB[1]++; //乙平局的次数+1}}printf("%d %d %d\n", infoA[0], infoA[1], infoA[2]);printf("%d %d %d\n", infoB[0], infoB[1], infoB[2]);//甲乙手势的获胜次数最多的idint idA = 0, idB = 0;for (int i = 0; i < 3; i++){if (handA[i] > handA[idA])idA = i;if (handB[i] > handB[idB])idB = i;}printf("%c %c\n", arr[idA], arr[idB]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1018 锤子剪刀布&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images.ptausercontent.com/72
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1012 数字分类</title>
    <link href="https://www.jiansunch.com/B1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB/"/>
    <id>https://www.jiansunch.com/B1012-数字分类/</id>
    <published>2019-04-24T15:45:54.000Z</published>
    <updated>2019-04-24T16:24:53.938Z</updated>
    
    <content type="html"><![CDATA[<h2>1012 数字分类</h2><blockquote><p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p></blockquote><ul><li>A​1​​ = 能被 5 整除的数字中所有偶数的和；</li><li>A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯；</li><li>A​3​​ = 被 5 除后余 2 的数字的个数；</li><li>A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；</li><li>A​5​​ = 被 5 除后余 4 的数字中最大数字。</li></ul><h3>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p><h3>输出格式：</h3><p>对给定的 N 个正整数，按题目要求计算 A​1​​~A​5​​ 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p><p>若其中某一类数字不存在，则在相应位置输出 <code>N</code>。</p><h3>输入样例 1：</h3><p><code>13 1 2 3 4 5 6 7 8 9 10 20 16 18</code></p><h3>输出样例 1：</h3><p><code>30 11 2 9.7 9</code></p><h3>输入样例 2：</h3><p><code>8 1 2 4 5 6 7 9 16</code></p><h3>输出样例 2：</h3><p><code>N 11 2 N 9</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int N, num;scanf("%d", &N);int arr[5] = {0};int count[5] = {0};for (int i = 0; i < N; i++){scanf("%d", &num);//A1if (num % 5 == 0){if (num % 2 == 0){arr[0] += num;count[0]++;}}//A2 转换为n1(0) + n3(2) - n2(1) - n4(3)...else if (num % 5 == 1){if (count[1] % 2 == 0){arr[1] += num;}else{arr[1] -= num;}count[1]++;}//A3else if (num % 5 == 2){count[2]++;}//A4else if (num % 5 == 3){arr[3] += num;count[3]++;}//A5else{if (num > arr[4]){arr[4] = num;}count[4]++;}}if (count[0] == 0)printf("N ");elseprintf("%d ", arr[0]);if (count[1] == 0)printf("N ");elseprintf("%d ", arr[1]);if (count[2] == 0)printf("N ");elseprintf("%d ", count[2]);if (count[3] == 0)printf("N ");elseprintf("%.1f ", (double)arr[3] / count[3]);if (count[4] == 0)printf("N");elseprintf("%d", arr[4]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1012 数字分类&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;A​1​​ = 能被 5 整除的数字中所有偶数的和；&lt;/li&gt;
&lt;li&gt;A​2​​ = 
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1008 数组元素循环右移问题</title>
    <link href="https://www.jiansunch.com/B1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>https://www.jiansunch.com/B1008-数组元素循环右移问题/</id>
    <published>2019-04-24T15:18:40.000Z</published>
    <updated>2019-04-24T15:45:17.208Z</updated>
    
    <content type="html"><![CDATA[<h2>1008 数组元素循环右移问题</h2><blockquote><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A​0​​A​1​​⋯A​N−1​​）变换为（A​N−M​​⋯A​N−1​​A​0​​A​1​​⋯A​N−M−1​​）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p></blockquote><h3>输入格式:</h3><p>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p><h3>输出格式:</h3><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><h3>输入样例:</h3><p><code>6 2</code><code>1 2 3 4 5 6</code></p><h3>输出样例:</h3><p><code>5 6 1 2 3 4</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int N, M;scanf("%d%d", &N, &M);//保证M < NM = M % N;int arr[N];for (int i = 0; i < N; i++){scanf("%d", &arr[i]);}//计数器，即已经打印了多少数int count = 0;//特殊情况,原样输出if (M == 0){for (int i = 0; i < N; i++){printf("%d", arr[i]);count++;if (count < N)printf(" ");}}else{count = 0;//输出N - M到N - 1for (int i = N - M; i <= N - 1; i++){printf("%d ", arr[i]);count++;}//输出0到N - M - 1for (int i = 0; i <= N - M - 1; i++){printf("%d", arr[i]);count++;if (count < N)printf(" ");}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1008 数组元素循环右移问题&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一个数组A中存有N（&amp;gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A​0​​A​1​​⋯A​N−1​​）变换为（A​N−M​​⋯A​N−1
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1046 划拳</title>
    <link href="https://www.jiansunch.com/B1046-%E5%88%92%E6%8B%B3/"/>
    <id>https://www.jiansunch.com/B1046-划拳/</id>
    <published>2019-04-24T11:03:05.000Z</published>
    <updated>2019-04-24T15:59:32.766Z</updated>
    
    <content type="html"><![CDATA[<h2>1046 划拳 （15 分)</h2><blockquote><p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。</p></blockquote><blockquote><p>下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。</p></blockquote><h3>输入格式：</h3><p>输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为：</p><p><code>甲喊 甲划 乙喊 乙划</code></p><p>其中<code>喊</code>是喊出的数字，<code>划</code>是划出的数字，均为不超过 100 的正整数（两只手一起划）。</p><h3>输出格式：</h3><p>在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。</p><h3>输入样例：</h3><p><code>5</code><code>8 10 9 12</code><code>5 10 5 10</code><code>3 8 5 12</code><code>12 18 1 13</code><code>4 16 12 15</code></p><h3>输出样例：</h3><p><code>1 2</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){//a1为甲喊的数,a2为甲比划的数,b1为乙喊的数,b2为乙比划的数//cupA为甲喝的杯数,cupB为乙喝的杯数int a1, a2, b1, b2, cupA = 0, cupB = 0;int N;scanf("%d", &N);while (N--){scanf("%d%d%d%d", &a1, &a2, &b1, &b2);//甲赢if (a1 + b1 == a2 && a1 + b1 != b2){cupB++;}//乙赢if (a1 + b1 == b2 && a1 + b1 != a2){cupA++;}}printf("%d %d\n", cupA, cupB);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1046 划拳 （15 分)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1026 程序运行时间</title>
    <link href="https://www.jiansunch.com/B1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4/"/>
    <id>https://www.jiansunch.com/B1026-程序运行时间/</id>
    <published>2019-04-24T10:27:24.000Z</published>
    <updated>2019-04-24T11:02:37.111Z</updated>
    
    <content type="html"><![CDATA[<h2>1026 程序运行时间</h2><blockquote><p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。</p></blockquote><blockquote><p>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p></blockquote><h3>输入格式：</h3><p>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10​​^7]。</p><h3>输出格式：</h3><p>在一行中输出被测函数运行的时间。运行时间必须按照 <code>hh:mm:ss</code>（即2位的 <code>时:分:秒</code>）格式输出；不足 1 秒的时间四舍五入到秒。</p><h3>输入样例：</h3><p><code>123 4577973</code></p><h3>输出样例：</h3><p><code>12:42:59</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int C1, C2;scanf("%d%d", &C1, &C2);int seconds = C2 - C1; //运行的时间(单位为s)//四舍五入if (seconds % 100 >= 50){seconds = seconds / 100 + 1;}else{seconds = seconds / 100;}printf("%02d:%02d:%02d", seconds / 3600, seconds % 3600 / 60, seconds % 60);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1026 程序运行时间&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tic
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1016 部分A+B</title>
    <link href="https://www.jiansunch.com/B1016-%E9%83%A8%E5%88%86A-B/"/>
    <id>https://www.jiansunch.com/B1016-部分A-B/</id>
    <published>2019-04-23T15:56:06.000Z</published>
    <updated>2019-04-24T03:49:30.412Z</updated>
    
    <content type="html"><![CDATA[<h2>1016 部分A+B （15 分)</h2><blockquote><p>正整数 A 的“D​A​​（为 1 位整数）部分”定义为由 A 中所有 D​A​​ 组成的新整数 P​A​​。例如：给定 A=3862767，D​A​​=6，则 A 的“6 部分”P​A​​ 是 66，因为 A 中有 2 个 6。</p></blockquote><blockquote><p>现给定 A、D​A​​、B、D​B​​，请编写程序计算 P​A​​+P​B​​。</p></blockquote><h3>输入格式：</h3><p>输入在一行中依次给出 A、D​A​​、B、D​B​​，中间以空格分隔，其中 0&lt;A,B&lt;10​^10​​。</p><h3>输出格式：</h3><p>在一行中输出 P​A​​+P​B​​ 的值。</p><h3>输入样例 1：</h3><p><code>3862767 6 13530293 3</code></p><h3>输出样例 1：</h3><p><code>399</code></p><h3>输入样例 2：</h3><p><code>3862767 1 13530293 8</code></p><h3>输出样例 2：</h3><p><code>0</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){long long A, Da, B, Db;scanf("%lld%lld%lld%lld", &A, &Da, &B, &Db);long long Pa = 0, Pb = 0;//检查A的每一位while (A != 0){if (A % 10 == Da)Pa = Pa * 10 + Da;A /= 10;}//检查B的每一位while (B != 0){if (B % 10 == Db)Pb = Pb * 10 + Db;B /= 10;}printf("%lld\n", Pa + Pb);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1016 部分A+B （15 分)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;正整数 A 的“D​A​​（为 1 位整数）部分”定义为由 A 中所有 D​A​​ 组成的新整数 P​A​​。例如：给定 A=3862767，D​A​​=6，则 A 的“6 部分”P​A​​ 是
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1011 A+B 和 C</title>
    <link href="https://www.jiansunch.com/B1011-A-B-%E5%92%8C-C/"/>
    <id>https://www.jiansunch.com/B1011-A-B-和-C/</id>
    <published>2019-04-23T15:21:29.000Z</published>
    <updated>2019-04-24T03:49:10.555Z</updated>
    
    <content type="html"><![CDATA[<h2>1011 A+B 和 C</h2><blockquote><p>给定区间 [−2​^31​​,2​^31​​] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。</p></blockquote><h3>输入格式：</h3><p>输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。</p><h3>输出格式：</h3><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 A+B&gt;C，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。</p><h3>输入样例：</h3><p><code>4</code><code>1 2 3</code><code>2 3 4</code><code>2147483647 0 2147483646</code><code>0 -2147483648 -2147483647</code></p><h3>输出样例：</h3><p><code>Case #1: false</code><code>Case #2: true</code><code>Case #3: true</code><code>Case #4: false</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int T, count = 1;scanf("%d", &T);long long A, B, C;//while版本while (T--){scanf("%lld%lld%lld", &A, &B, &C);if (A + B > C){printf("Case #%d: true\n", count++);}else{printf("Case #%d: false\n", count++);}}//for版本// for (int i = 1; i <= T; i++)// {// scanf("%lld%lld%lld", &A, &B, &C);// if (A + B > C)// {// printf("Case #%d: true\n", i);// }// else// {// printf("Case #%d: false\n", i);// }// }return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1011 A+B 和 C&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给定区间 [−2​^31​​,2​^31​​] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;输入格式：&lt;/h3&gt;
&lt;p&gt;输入第 1 行给出
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1032 挖掘机技术哪家强</title>
    <link href="https://www.jiansunch.com/B1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA/"/>
    <id>https://www.jiansunch.com/B1032-挖掘机技术哪家强/</id>
    <published>2019-04-22T14:46:01.000Z</published>
    <updated>2019-04-24T01:38:55.372Z</updated>
    
    <content type="html"><![CDATA[<h2>1032 挖掘机技术哪家强</h2><blockquote><p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p></blockquote><h3>输入格式：</h3><p>输入在第 1 行给出不超过 10​5​​ 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p><h3>输出格式：</h3><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p><h3>输入样例：</h3><p><code>6</code><code>3 65</code><code>2 80</code><code>1 100</code><code>2 70</code><code>3 40</code><code>3 0</code></p><h3>输出样例：</h3><p><code>2 150</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main() {int N, schoolId, schoolScore;int school[100001] = {0};scanf("%d", &N);for(int i = 0; i < N; i++) {scanf("%d%d", &schoolId, &schoolScore);school[schoolId] += schoolScore;}int topId = 1, topScore = -1;for(int i = 1; i <= N; i++) {if(school[i] > topScore) {topScore = school[i];topId = i;}}printf("%d %d\n", topId, topScore);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1032 挖掘机技术哪家强&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;输入格式：&lt;/h3&gt;
&lt;p&gt;输入在第 1 
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>B1001 害死人不偿命的(3n+1)猜想</title>
    <link href="https://www.jiansunch.com/B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3/"/>
    <id>https://www.jiansunch.com/B1001-害死人不偿命的-3n-1-猜想/</id>
    <published>2019-04-22T10:35:37.000Z</published>
    <updated>2019-04-24T03:42:49.954Z</updated>
    
    <content type="html"><![CDATA[<h2>1001 害死人不偿命的(3n+1)猜想</h2><blockquote><p>卡拉兹(Callatz)猜想：对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？</p></blockquote><h3>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 n 的值。</p><h3>输出格式：</h3><p>输出从 n 计算到 1 需要的步数。</p><h3>输入样例：</h3><p><code>3</code></p><h3>输出样例：</h3><p><code>5</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){    int n, step = 0;    scanf("%d", &n);    while (n != 1)    {        if (n % 2 == 0)        {            n /= 2;        }        else        {            n = (3 * n + 1) / 2;        }        step++;    }    printf("%d\n", step);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;1001 害死人不偿命的(3n+1)猜想&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;卡拉兹(Callatz)猜想：
对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>PAT_Solution</title>
    <link href="https://www.jiansunch.com/PAT-Solution/"/>
    <id>https://www.jiansunch.com/PAT-Solution/</id>
    <published>2019-04-22T10:22:06.000Z</published>
    <updated>2019-04-26T10:26:25.576Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="https://pintia.cn/" target="_blank" rel="noopener">PAT</a></h1><h2>Advanced Level</h2><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">Problem</th><th style="text-align:center">Solution</th></tr></thead><tbody><tr><td style="text-align:center">A1002</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000" target="_blank" rel="noopener">A+B for Polynomials</a></td><td style="text-align:center"><a href>C++</a></td></tr><tr><td style="text-align:center">A1009</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805509540921344" target="_blank" rel="noopener">Product of Polynomials</a></td><td style="text-align:center"><a href>C++</a></td></tr><tr><td style="text-align:center">A1042</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805442671132672" target="_blank" rel="noopener">Shuffling Machine</a></td><td style="text-align:center"><a href="/A1042-Shuffling-Machine">C++</a></td></tr><tr><td style="text-align:center">A1046</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805435700199424" target="_blank" rel="noopener">Shortest Distance</a></td><td style="text-align:center"><a href="/A1046-Shortest-Distance">C++</a></td></tr><tr><td style="text-align:center">A1065</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805406352654336" target="_blank" rel="noopener">A+B and C (64bit)</a></td><td style="text-align:center"><a href="/A1065-A-B-and-C-64bit">C++</a></td></tr></tbody></table><h2>Basic Level</h2><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">Problem</th><th style="text-align:center">Solution</th></tr></thead><tbody><tr><td style="text-align:center">B1001</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805325918486528" target="_blank" rel="noopener">害死人不偿命的(3n+1)猜想</a></td><td style="text-align:center"><a href="/B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3">C++</a></td></tr><tr><td style="text-align:center">B1008</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805316250615808" target="_blank" rel="noopener">数组元素循环右移问题</a></td><td style="text-align:center"><a href="/B1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98">C++</a></td></tr><tr><td style="text-align:center">B1010</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805313708867584" target="_blank" rel="noopener">一元多项式求导</a></td><td style="text-align:center"><a href="/B1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC">C++</a></td></tr><tr><td style="text-align:center">B1011</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805312417021952" target="_blank" rel="noopener">A+B 和 C</a></td><td style="text-align:center"><a href="/B1011-A-B-%E5%92%8C-C">C++</a></td></tr><tr><td style="text-align:center">B1012</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805311146147840" target="_blank" rel="noopener">数字分类</a></td><td style="text-align:center"><a href="/B1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB">C++</a></td></tr><tr><td style="text-align:center">B1016</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805306310115328" target="_blank" rel="noopener">部分A+B</a></td><td style="text-align:center"><a href="/B1016-%E9%83%A8%E5%88%86A-B">C++</a></td></tr><tr><td style="text-align:center">B1018</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805304020025344" target="_blank" rel="noopener">锤子剪刀布</a></td><td style="text-align:center"><a href="/B1018-%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83">C++</a></td></tr><tr><td style="text-align:center">B1026</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805295203598336" target="_blank" rel="noopener">程序运行时间</a></td><td style="text-align:center"><a href="/B1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4">C++</a></td></tr><tr><td style="text-align:center">B1032</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805289432236032" target="_blank" rel="noopener">挖掘机技术哪家强</a></td><td style="text-align:center"><a href="/B1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA">C++</a></td></tr><tr><td style="text-align:center">B1046</td><td style="text-align:center"><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805277847568384" target="_blank" rel="noopener">划拳</a></td><td style="text-align:center"><a href="/B1046-%E5%88%92%E6%8B%B3">C++</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;a href=&quot;https://pintia.cn/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PAT&lt;/a&gt;&lt;/h1&gt;
&lt;h2&gt;Advanced Level&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-al
      
    
    </summary>
    
      <category term="题集" scheme="https://www.jiansunch.com/categories/%E9%A2%98%E9%9B%86/"/>
    
    
      <category term="PAT" scheme="https://www.jiansunch.com/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>百钱白鸡</title>
    <link href="https://www.jiansunch.com/%E7%99%BE%E9%92%B1%E7%99%BD%E9%B8%A1/"/>
    <id>https://www.jiansunch.com/百钱白鸡/</id>
    <published>2019-04-16T15:44:26.000Z</published>
    <updated>2019-04-21T09:35:43.954Z</updated>
    
    <content type="html"><![CDATA[<h1>百钱白鸡</h1><h2>题目描述</h2><blockquote><p>鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一. 百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何—— 张丘建《算经》</p></blockquote><h2>求解方法</h2><ul><li>先构造可能的解的集合S={(X,Y,Z)|0&lt;=X,Y,Z&lt;=100} X, Y, Z分别代表买公鸡, 母鸡和小鸡的只数</li><li>然后验证条件X+Y+Z=100, 5X+3Y+Z/3=100</li><li>复杂度: O(100^2)</li></ul><h2>code</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>#include <time.h>clock_t start, stop;double duration;#define MAXN 10#define MAXK 1e7#define CLK_TCK 18.2int main(){    start = clock(); //开始计时    int z;    for (int x = 0; x <= 100; x++)    {        for (int y = 0; y <= 100 - x; y++)        {            z = 100 - x - y;            if (z % 3 == 0 && 5 * x + 3 * y + z / 3 == 100)            {                printf("x=%d, y=%d, z=%d\n", x, y, z);            }        }    }    stop = clock(); //停止计时    printf("ticks1 = %f\n", (double)(stop - start));    printf("duration1 = %6.2e\n", duration);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;百钱白鸡&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一. 百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何
—— 张丘建《算经》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;求解方法&lt;/h2&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="algo_base" scheme="https://www.jiansunch.com/tags/algo-base/"/>
    
  </entry>
  
  <entry>
    <title>A+B</title>
    <link href="https://www.jiansunch.com/A-B/"/>
    <id>https://www.jiansunch.com/A-B/</id>
    <published>2019-04-11T15:51:44.000Z</published>
    <updated>2019-04-16T15:45:49.274Z</updated>
    
    <content type="html"><![CDATA[<h1>A+B 输入输出练习I</h1><h2>题目描述</h2><p>你的任务是计算a+b。这是为了acm初学者专门设计的题目。你肯定发现还有其他题目跟这道题的标题类似，这些问题也都是专门为初学者提供的。</p><h2>输入</h2><p>输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。</p><h2>输出</h2><p>对于输入的每对a和b，你需要依次输出a、b的和。</p><p>如对于输入中的第二对a和b，在输出中它们的和应该也在第二行。</p><h2>样例输入</h2><p><code>1 5</code><code>10 20</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b;    while(scanf("%d%d", &a, &b) != EOF){        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。</p><h2>输出</h2><p>对于输入的每对a和b，你需要在相应的行输出a、b的和。如第二对a和b，对应的和也输出在第二行。</p><h2>样例输入</h2><p><code>2</code><code>1 5</code><code>10 20</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b, N;    scanf("%d", &N);    while (N--)    {        scanf("%d%d", &a, &b);        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>输入中每行是一对a和b。其中会有一对是0和0标志着输入结束，且这一对不要计算。</p><h2>输出</h2><p>对于输入的每对a和b，你需要在相应的行输出a、b的和。</p><p>如第二对a和b，他们的和也输出在第二行。</p><h2>样例输入</h2><p><code>1 5</code><code>10 20</code><code>0 0</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b;    while (scanf("%d%d", &a, &b), a || b)    {        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>输入的第一行为一个整数N，接下来N行每行先输入一个整数M，然后在同一行内输入M个整数。</p><h2>输出</h2><p>对于每组输入，输出M个数的和，每组输出之间输出一个空行。</p><h2>样例输入</h2><p><code>3</code><code>4 1 2 3 4</code><code>5 1 2 3 4 5</code><code>3 1 2 3</code></p><h2>样例输出</h2><p><code>10</code><code></code><code>15</code><code></code><code>6</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b, N, M, num;    scanf("%d", &N);    while (N--)    {        int sum = 0;        scanf("%d", &M);        for (int i = 0; i < M; i++)        {            scanf("%d", &num);            sum += num;        }        printf("%d\n", sum);        if (N > 0)        {            printf("\n");        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;A+B 输入输出练习I&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;你的任务是计算a+b。这是为了acm初学者专门设计的题目。你肯定发现还有其他题目跟这道题的标题类似，这些问题也都是专门为初学者提供的。&lt;/p&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;p&gt;输入包含一系列的a和b对，通过
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="codeup" scheme="https://www.jiansunch.com/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>6-12 解密</title>
    <link href="https://www.jiansunch.com/6-12-%E8%A7%A3%E5%AF%86/"/>
    <id>https://www.jiansunch.com/6-12-解密/</id>
    <published>2019-04-03T15:09:05.000Z</published>
    <updated>2019-04-03T15:17:44.675Z</updated>
    
    <content type="html"><![CDATA[<h1>习题6-12 解密</h1><h2>题目描述</h2><p>有一行电文，已按如下规律译成密码：</p><p>A--&gt;Z        a--&gt;z</p><p>B--&gt;Y        b--&gt;y</p><p>C--&gt;X        c--&gt;x</p><p>......          ......</p><p>即第一个字母变成第26个字母，第i个字母变成第（26-i+1)个字母，非字母字符不变。要求根据密码译回原文，并输出。</p><h2>输入</h2><p>输入一行密文</p><h2>输出</h2><p>解密后的原文，单独占一行。</p><h2>样例输入</h2><p><code>ZYX123zyx</code></p><h2>样例输出</h2><p><code>ABC123abc</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    char pass[100] = {};    gets(pass);    for (int i = 0; i < 100; i++)    {        if (pass[i] >= 'a' && pass[i] <= 'z')        {            pass[i] = 'a' + 'z' - pass[i];        }        else if (pass[i] >= 'A' && pass[i] <= 'Z')        {            pass[i] = 'A' + 'Z' - pass[i];        }    }    puts(pass);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;习题6-12 解密&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有一行电文，已按如下规律译成密码：&lt;/p&gt;
&lt;p&gt;A--&amp;gt;Z        a--&amp;gt;z&lt;/p&gt;
&lt;p&gt;B--&amp;gt;Y        b--&amp;gt;y&lt;/p&gt;
&lt;p&gt;C--&amp;gt;X       
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="codeup" scheme="https://www.jiansunch.com/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>6-6 杨辉三角</title>
    <link href="https://www.jiansunch.com/6-6-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    <id>https://www.jiansunch.com/6-6-杨辉三角/</id>
    <published>2019-04-03T15:08:24.000Z</published>
    <updated>2019-04-03T15:17:41.717Z</updated>
    
    <content type="html"><![CDATA[<h1>习题6-6 杨辉三角</h1><h2>题目描述</h2><p>按要求输入如下格式的杨辉三角</p><p>11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1</p><p>最多输出10层</p><h2>输入</h2><p>输入只包含一个正整数n，表示将要输出的杨辉三角的层数。</p><h2>输出</h2><p>对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开</p><h2>样例输入</h2><p><code>5</code></p><h2>样例输出</h2><p><code>1</code><code>1 1</code><code>1 2 1</code><code>1 3 3 1</code><code>1 4 6 4 1</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int n;    scanf("%d", &n);    int a[n][n];    if (n <= 10)    {        for (int i = 0; i < n; i++)        {            for (int j = 0; j <= i; j++)            {                if (j == 0 || j == i)                {                    a[i][j] = 1;                }                //该元素的值等于正上方和左上方元素的和                else                {                    a[i][j] = a[i - 1][j] + a[i - 1][j - 1];                }                printf("%d ", a[i][j]);            }            printf("\n");        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;习题6-6 杨辉三角&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;按要求输入如下格式的杨辉三角&lt;/p&gt;
&lt;p&gt;1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1&lt;/p&gt;
&lt;p&gt;最多输出10层&lt;/p&gt;
&lt;h2&gt;输入&lt;/h2&gt;
&lt;p&gt;输入只
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="codeup" scheme="https://www.jiansunch.com/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>6-4 有序插入</title>
    <link href="https://www.jiansunch.com/6-4-%E6%9C%89%E5%BA%8F%E6%8F%92%E5%85%A5/"/>
    <id>https://www.jiansunch.com/6-4-有序插入/</id>
    <published>2019-04-03T15:06:49.000Z</published>
    <updated>2019-04-03T15:07:55.954Z</updated>
    
    <content type="html"><![CDATA[<h1>习题6-4 有序插入</h1><h2>题目描述</h2><p>有一个已排好序的数组，要求输入一个数后，按原来排序的规律将它插入到数组中。</p><p>假设数组长度为10，数组中前9个数（这9个数要求从键盘上输入，输入时要满足自小到大的输入顺序）已经按从小到大进行排序。</p><p>然后再从键盘上输入一个整数，将此整数插入到前有序的9个数中，使得最终的10个数依然是从小到大有序的。</p><h2>输入</h2><p>第一行输入以空格分隔的9个整数数，要求按从小到大的顺序输入。</p><p>第二行输入一个整数</p><h2>输出</h2><p>从小到大输出这10个数，每个数一行。</p><h2>样例输入</h2><p><code>1 11 21 31 41 51 61 71 81</code><code>45</code></p><h2>样例输出</h2><p><code>1 11 21 31 41 45 51 61 71 81</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a[10] = {0};    for (int i = 0; i < 9; i++)    {        scanf("%d", &a[i]);    }    scanf("%d", &a[9]);    //采用冒泡排序    //趟数 n - 1    for (int i = 1; i <= 9; i++)    {        //比较次数 n - i        for (int j = 0; j < 10 - i; j++)        {            if (a[j] > a[j + 1])            {                int temp = a[j];                a[j] = a[j + 1];                a[j + 1] = temp;            }        }    }    for (int i = 0; i < 10; i++)    {        printf("%d ", a[i]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;习题6-4 有序插入&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有一个已排好序的数组，要求输入一个数后，按原来排序的规律将它插入到数组中。&lt;/p&gt;
&lt;p&gt;假设数组长度为10，数组中前9个数（这9个数要求从键盘上输入，输入时要满足自小到大的输入顺序）已经按从小到大进行排序
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="codeup" scheme="https://www.jiansunch.com/tags/codeup/"/>
    
  </entry>
  
  <entry>
    <title>4-1 一元二次方程求根</title>
    <link href="https://www.jiansunch.com/4-1-%E4%B8%80%E5%85%83%E4%BA%8C%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9/"/>
    <id>https://www.jiansunch.com/4-1-一元二次方程求根/</id>
    <published>2019-04-03T02:45:23.000Z</published>
    <updated>2019-04-03T15:10:08.956Z</updated>
    
    <content type="html"><![CDATA[<h1>例题4-1 一元二次方程求根</h1><h2>题目描述</h2><p>求一元二次方程ax2+bx+c=0的根，三个系数a, b, c由键盘输入，且a不能为0，但不保证b2-4ac&gt;0。</p><p>程序中所涉及的变量均为double类型。</p><h2>输入</h2><p>以空格分隔的一元二次方程的三个系数，双精度double类型</p><h2>输出</h2><p>分行输出两个根如下（注意末尾的换行）：</p><p>r1=第一个根</p><p>r2=第二个根</p><p>结果输出时，宽度占7位，其中小数部分2位。</p><p>如果方程无实根，输出一行如下信息（注意末尾的换行）：</p><p>No real roots!</p><h2>样例输入</h2><p><code>1 2 3</code></p><h2>样例输出</h2><p><code>No real roots!</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>#include <cmath>int main(){    double a, b, c;    double r1, r2;    scanf("%lf%lf%lf", &a, &b, &c);    if (a)    {        if (pow(b, 2) < 4 * a * c)        {            printf("No real roots!");        }        else        {            r1 = (-b + sqrt(pow(b, 2) - 4 * a * c)) / 2 * a;            r2 = (-b - sqrt(pow(b, 2) - 4 * a * c)) / 2 * a;            printf("r1=%f\nr2=%f", r1, r2);        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;例题4-1 一元二次方程求根&lt;/h1&gt;
&lt;h2&gt;题目描述&lt;/h2&gt;
&lt;p&gt;求一元二次方程ax2+bx+c=0的根，三个系数a, b, c由键盘输入，且a不能为0，但不保证b2-4ac&amp;gt;0。&lt;/p&gt;
&lt;p&gt;程序中所涉及的变量均为double类型。&lt;/p&gt;
&lt;h2&gt;输入
      
    
    </summary>
    
      <category term="code" scheme="https://www.jiansunch.com/categories/code/"/>
    
    
      <category term="codeup" scheme="https://www.jiansunch.com/tags/codeup/"/>
    
  </entry>
  
</feed>
