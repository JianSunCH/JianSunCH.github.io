<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>B1012 数字分类</title>
      <link href="/b1012-shu-zi-fen-lei/"/>
      <url>/b1012-shu-zi-fen-lei/</url>
      
        <content type="html"><![CDATA[<h2>1012 数字分类</h2><blockquote><p>给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字：</p></blockquote><ul><li>A​1​​ = 能被 5 整除的数字中所有偶数的和；</li><li>A​2​​ = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n​1​​−n​2​​+n​3​​−n​4​​⋯；</li><li>A​3​​ = 被 5 除后余 2 的数字的个数；</li><li>A​4​​ = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位；</li><li>A​5​​ = 被 5 除后余 4 的数字中最大数字。</li></ul><h3>输入格式：</h3><p>每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。</p><h3>输出格式：</h3><p>对给定的 N 个正整数，按题目要求计算 A​1​​~A​5​​ 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。</p><p>若其中某一类数字不存在，则在相应位置输出 <code>N</code>。</p><h3>输入样例 1：</h3><p><code>13 1 2 3 4 5 6 7 8 9 10 20 16 18</code></p><h3>输出样例 1：</h3><p><code>30 11 2 9.7 9</code></p><h3>输入样例 2：</h3><p><code>8 1 2 4 5 6 7 9 16</code></p><h3>输出样例 2：</h3><p><code>N 11 2 N 9</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int N, num;scanf("%d", &N);int arr[5] = {0};int count[5] = {0};for (int i = 0; i < N; i++){scanf("%d", &num);//A1if (num % 5 == 0){if (num % 2 == 0){arr[0] += num;count[0]++;}}//A2 转换为n1(0) + n3(2) - n2(1) - n4(3)...else if (num % 5 == 1){if (count[1] % 2 == 0){arr[1] += num;}else{arr[1] -= num;}count[1]++;}//A3else if (num % 5 == 2){count[2]++;}//A4else if (num % 5 == 3){arr[3] += num;count[3]++;}//A5else{if (num > arr[4]){arr[4] = num;}count[4]++;}}if (count[0] == 0)printf("N ");elseprintf("%d ", arr[0]);if (count[1] == 0)printf("N ");elseprintf("%d ", arr[1]);if (count[2] == 0)printf("N ");elseprintf("%d ", count[2]);if (count[3] == 0)printf("N ");elseprintf("%.1f ", (double)arr[3] / count[3]);if (count[4] == 0)printf("N");elseprintf("%d", arr[4]);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B1008 数组元素循环右移问题</title>
      <link href="/b1008-shu-zu-yuan-su-xun-huan-you-yi-wen-ti/"/>
      <url>/b1008-shu-zu-yuan-su-xun-huan-you-yi-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2>1008 数组元素循环右移问题</h2><blockquote><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将A中的数据由（A​0​​A​1​​⋯A​N−1​​）变换为（A​N−M​​⋯A​N−1​​A​0​​A​1​​⋯A​N−M−1​​）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p></blockquote><h3>输入格式:</h3><p>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p><h3>输出格式:</h3><p>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><h3>输入样例:</h3><p><code>6 2</code><code>1 2 3 4 5 6</code></p><h3>输出样例:</h3><p><code>5 6 1 2 3 4</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int N, M;scanf("%d%d", &N, &M);//保证M < NM = M % N;int arr[N];for (int i = 0; i < N; i++){scanf("%d", &arr[i]);}//计数器，即已经打印了多少数int count = 0;//特殊情况,原样输出if (M == 0){for (int i = 0; i < N; i++){printf("%d", arr[i]);count++;if (count < N)printf(" ");}}else{count = 0;//输出N - M到N - 1for (int i = N - M; i <= N - 1; i++){printf("%d ", arr[i]);count++;}//输出0到N - M - 1for (int i = 0; i <= N - M - 1; i++){printf("%d", arr[i]);count++;if (count < N)printf(" ");}}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B1046 划拳</title>
      <link href="/b1046-hua-quan/"/>
      <url>/b1046-hua-quan/</url>
      
        <content type="html"><![CDATA[<h2>1046 划拳 （15 分)</h2><blockquote><p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。</p></blockquote><blockquote><p>下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。</p></blockquote><h3>输入格式：</h3><p>输入第一行先给出一个正整数 N（≤100），随后 N 行，每行给出一轮划拳的记录，格式为：</p><p><code>甲喊 甲划 乙喊 乙划</code></p><p>其中<code>喊</code>是喊出的数字，<code>划</code>是划出的数字，均为不超过 100 的正整数（两只手一起划）。</p><h3>输出格式：</h3><p>在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。</p><h3>输入样例：</h3><p><code>5</code><code>8 10 9 12</code><code>5 10 5 10</code><code>3 8 5 12</code><code>12 18 1 13</code><code>4 16 12 15</code></p><h3>输出样例：</h3><p><code>1 2</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){//a1为甲喊的数,a2为甲比划的数,b1为乙喊的数,b2为乙比划的数//cupA为甲喝的杯数,cupB为乙喝的杯数int a1, a2, b1, b2, cupA = 0, cupB = 0;int N;scanf("%d", &N);while (N--){scanf("%d%d%d%d", &a1, &a2, &b1, &b2);//甲赢if (a1 + b1 == a2 && a1 + b1 != b2){cupB++;}//乙赢if (a1 + b1 == b2 && a1 + b1 != a2){cupA++;}}printf("%d %d\n", cupA, cupB);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B1026 程序运行时间</title>
      <link href="/b1026-cheng-xu-yun-xing-shi-jian/"/>
      <url>/b1026-cheng-xu-yun-xing-shi-jian/</url>
      
        <content type="html"><![CDATA[<h2>1026 程序运行时间</h2><blockquote><p>要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。</p></blockquote><blockquote><p>这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。</p></blockquote><h3>输入格式：</h3><p>输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,10​​^7]。</p><h3>输出格式：</h3><p>在一行中输出被测函数运行的时间。运行时间必须按照 <code>hh:mm:ss</code>（即2位的 <code>时:分:秒</code>）格式输出；不足 1 秒的时间四舍五入到秒。</p><h3>输入样例：</h3><p><code>123 4577973</code></p><h3>输出样例：</h3><p><code>12:42:59</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int C1, C2;scanf("%d%d", &C1, &C2);int seconds = C2 - C1; //运行的时间(单位为s)//四舍五入if (seconds % 100 >= 50){seconds = seconds / 100 + 1;}else{seconds = seconds / 100;}printf("%02d:%02d:%02d", seconds / 3600, seconds % 3600 / 60, seconds % 60);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B1016 部分A+B</title>
      <link href="/b1016-bu-fen-a-b/"/>
      <url>/b1016-bu-fen-a-b/</url>
      
        <content type="html"><![CDATA[<h2>1016 部分A+B （15 分)</h2><blockquote><p>正整数 A 的“D​A​​（为 1 位整数）部分”定义为由 A 中所有 D​A​​ 组成的新整数 P​A​​。例如：给定 A=3862767，D​A​​=6，则 A 的“6 部分”P​A​​ 是 66，因为 A 中有 2 个 6。</p></blockquote><blockquote><p>现给定 A、D​A​​、B、D​B​​，请编写程序计算 P​A​​+P​B​​。</p></blockquote><h3>输入格式：</h3><p>输入在一行中依次给出 A、D​A​​、B、D​B​​，中间以空格分隔，其中 0&lt;A,B&lt;10​^10​​。</p><h3>输出格式：</h3><p>在一行中输出 P​A​​+P​B​​ 的值。</p><h3>输入样例 1：</h3><p><code>3862767 6 13530293 3</code></p><h3>输出样例 1：</h3><p><code>399</code></p><h3>输入样例 2：</h3><p><code>3862767 1 13530293 8</code></p><h3>输出样例 2：</h3><p><code>0</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){long long A, Da, B, Db;scanf("%lld%lld%lld%lld", &A, &Da, &B, &Db);long long Pa = 0, Pb = 0;//检查A的每一位while (A != 0){if (A % 10 == Da)Pa = Pa * 10 + Da;A /= 10;}//检查B的每一位while (B != 0){if (B % 10 == Db)Pb = Pb * 10 + Db;B /= 10;}printf("%lld\n", Pa + Pb);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B1011 A+B 和 C</title>
      <link href="/b1011-a-b-he-c/"/>
      <url>/b1011-a-b-he-c/</url>
      
        <content type="html"><![CDATA[<h2>1011 A+B 和 C</h2><blockquote><p>给定区间 [−2​^31​​,2​^31​​] 内的 3 个整数 A、B 和 C，请判断 A+B 是否大于 C。</p></blockquote><h3>输入格式：</h3><p>输入第 1 行给出正整数 T (≤10)，是测试用例的个数。随后给出 T 组测试用例，每组占一行，顺序给出 A、B 和 C。整数间以空格分隔。</p><h3>输出格式：</h3><p>对每组测试用例，在一行中输出 <code>Case #X: true</code> 如果 A+B&gt;C，否则输出 <code>Case #X: false</code>，其中 <code>X</code> 是测试用例的编号（从 1 开始）。</p><h3>输入样例：</h3><p><code>4</code><code>1 2 3</code><code>2 3 4</code><code>2147483647 0 2147483646</code><code>0 -2147483648 -2147483647</code></p><h3>输出样例：</h3><p><code>Case #1: false</code><code>Case #2: true</code><code>Case #3: true</code><code>Case #4: false</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){int T, count = 1;scanf("%d", &T);long long A, B, C;//while版本while (T--){scanf("%lld%lld%lld", &A, &B, &C);if (A + B > C){printf("Case #%d: true\n", count++);}else{printf("Case #%d: false\n", count++);}}//for版本// for (int i = 1; i <= T; i++)// {// scanf("%lld%lld%lld", &A, &B, &C);// if (A + B > C)// {// printf("Case #%d: true\n", i);// }// else// {// printf("Case #%d: false\n", i);// }// }return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B1032 挖掘机技术哪家强</title>
      <link href="/b1032-wa-jue-ji-ji-zhu-na-jia-qiang/"/>
      <url>/b1032-wa-jue-ji-ji-zhu-na-jia-qiang/</url>
      
        <content type="html"><![CDATA[<h2>1032 挖掘机技术哪家强</h2><blockquote><p>为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p></blockquote><h3>输入格式：</h3><p>输入在第 1 行给出不超过 10​5​​ 的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p><h3>输出格式：</h3><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p><h3>输入样例：</h3><p><code>6</code><code>3 65</code><code>2 80</code><code>1 100</code><code>2 70</code><code>3 40</code><code>3 0</code></p><h3>输出样例：</h3><p><code>2 150</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main() {int N, schoolId, schoolScore;int school[100001] = {0};scanf("%d", &N);for(int i = 0; i < N; i++) {scanf("%d%d", &schoolId, &schoolScore);school[schoolId] += schoolScore;}int topId = 1, topScore = -1;for(int i = 1; i <= N; i++) {if(school[i] > topScore) {topScore = school[i];topId = i;}}printf("%d %d\n", topId, topScore);return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B1001 害死人不偿命的(3n+1)猜想</title>
      <link href="/b1001-hai-si-ren-bu-chang-ming-de-3n-1-cai-xiang/"/>
      <url>/b1001-hai-si-ren-bu-chang-ming-de-3n-1-cai-xiang/</url>
      
        <content type="html"><![CDATA[<h2>1001 害死人不偿命的(3n+1)猜想</h2><blockquote><p>卡拉兹(Callatz)猜想：对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？</p></blockquote><h3>输入格式：</h3><p>每个测试输入包含 1 个测试用例，即给出正整数 n 的值。</p><h3>输出格式：</h3><p>输出从 n 计算到 1 需要的步数。</p><h3>输入样例：</h3><p><code>3</code></p><h3>输出样例：</h3><p><code>5</code></p><h3>解答</h3><pre class="line-numbers language-language-c"><code class="language-language-c">#include <bits/stdc++.h>int main(){    int n, step = 0;    scanf("%d", &n);    while (n != 1)    {        if (n % 2 == 0)        {            n /= 2;        }        else        {            n = (3 * n + 1) / 2;        }        step++;    }    printf("%d\n", step);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PAT_Solution</title>
      <link href="/pat-solution/"/>
      <url>/pat-solution/</url>
      
        <content type="html"><![CDATA[<h1>PAT解答</h1><h2>Advanced Level</h2><table><thead><tr><th style="text-align:center">标号</th><th style="text-align:center">标题</th><th style="text-align:center">解决方案</th></tr></thead><tbody><tr><td style="text-align:center">A1002</td><td style="text-align:center">A+B for Polynomials</td><td style="text-align:center"><a href>C++</a></td></tr><tr><td style="text-align:center">A1009</td><td style="text-align:center">Product of Polynomials</td><td style="text-align:center"><a href>C++</a></td></tr><tr><td style="text-align:center">A1042</td><td style="text-align:center">Shuffling Machine</td><td style="text-align:center"><a href>C++</a></td></tr><tr><td style="text-align:center">A1046</td><td style="text-align:center">Shortest Distance</td><td style="text-align:center"><a href>C++</a></td></tr><tr><td style="text-align:center">A1065</td><td style="text-align:center">A+B and C (64bit)</td><td style="text-align:center"><a href>C++</a></td></tr></tbody></table><h2>Basic Level</h2><table><thead><tr><th style="text-align:center">标号</th><th style="text-align:center">标题</th><th style="text-align:center">解决方案</th></tr></thead><tbody><tr><td style="text-align:center">B1001</td><td style="text-align:center">害死人不偿命的(3n+1)猜想</td><td style="text-align:center"><a href="/B1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3">C++</a></td></tr><tr><td style="text-align:center">B1008</td><td style="text-align:center">数组元素循环右移问题</td><td style="text-align:center"><a href="/B1008-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98">C++</a></td></tr><tr><td style="text-align:center">B1010</td><td style="text-align:center">一元多项式求导</td><td style="text-align:center"><a href>C++</a></td></tr><tr><td style="text-align:center">B1011</td><td style="text-align:center">A+B 和 C</td><td style="text-align:center"><a href="/B1011-A-B-%E5%92%8C-C">C++</a></td></tr><tr><td style="text-align:center">B1012</td><td style="text-align:center">数字分类</td><td style="text-align:center"><a href="/B1012-%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB">C++</a></td></tr><tr><td style="text-align:center">B1016</td><td style="text-align:center">部分A+B</td><td style="text-align:center"><a href="/B1016-%E9%83%A8%E5%88%86A-B">C++</a></td></tr><tr><td style="text-align:center">B1018</td><td style="text-align:center">锤子剪刀布</td><td style="text-align:center"><a href>C++</a></td></tr><tr><td style="text-align:center">B1026</td><td style="text-align:center">程序运行时间</td><td style="text-align:center"><a href="/B1026-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4">C++</a></td></tr><tr><td style="text-align:center">B1032</td><td style="text-align:center">挖掘机技术哪家强</td><td style="text-align:center"><a href="/B1032-%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA">C++</a></td></tr><tr><td style="text-align:center">B1046</td><td style="text-align:center">划拳</td><td style="text-align:center"><a href="/B1046-%E5%88%92%E6%8B%B3">C++</a></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 题集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PAT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百钱白鸡</title>
      <link href="/bai-qian-bai-ji/"/>
      <url>/bai-qian-bai-ji/</url>
      
        <content type="html"><![CDATA[<h1>百钱白鸡</h1><h2>题目描述</h2><blockquote><p>鸡翁一值钱五, 鸡母一值钱三, 鸡雏三值钱一. 百钱买百鸡, 问鸡翁, 鸡母, 鸡雏各几何—— 张丘建《算经》</p></blockquote><h2>求解方法</h2><ul><li>先构造可能的解的集合S={(X,Y,Z)|0&lt;=X,Y,Z&lt;=100} X, Y, Z分别代表买公鸡, 母鸡和小鸡的只数</li><li>然后验证条件X+Y+Z=100, 5X+3Y+Z/3=100</li><li>复杂度: O(100^2)</li></ul><h2>code</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>#include <time.h>clock_t start, stop;double duration;#define MAXN 10#define MAXK 1e7#define CLK_TCK 18.2int main(){    start = clock(); //开始计时    int z;    for (int x = 0; x <= 100; x++)    {        for (int y = 0; y <= 100 - x; y++)        {            z = 100 - x - y;            if (z % 3 == 0 && 5 * x + 3 * y + z / 3 == 100)            {                printf("x=%d, y=%d, z=%d\n", x, y, z);            }        }    }    stop = clock(); //停止计时    printf("ticks1 = %f\n", (double)(stop - start));    printf("duration1 = %6.2e\n", duration);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algo_base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A+B</title>
      <link href="/a-b/"/>
      <url>/a-b/</url>
      
        <content type="html"><![CDATA[<h1>A+B 输入输出练习I</h1><h2>题目描述</h2><p>你的任务是计算a+b。这是为了acm初学者专门设计的题目。你肯定发现还有其他题目跟这道题的标题类似，这些问题也都是专门为初学者提供的。</p><h2>输入</h2><p>输入包含一系列的a和b对，通过空格隔开。一对a和b占一行。</p><h2>输出</h2><p>对于输入的每对a和b，你需要依次输出a、b的和。</p><p>如对于输入中的第二对a和b，在输出中它们的和应该也在第二行。</p><h2>样例输入</h2><p><code>1 5</code><code>10 20</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b;    while(scanf("%d%d", &a, &b) != EOF){        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>第一行是一个整数N，表示后面会有N行a和b，通过空格隔开。</p><h2>输出</h2><p>对于输入的每对a和b，你需要在相应的行输出a、b的和。如第二对a和b，对应的和也输出在第二行。</p><h2>样例输入</h2><p><code>2</code><code>1 5</code><code>10 20</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b, N;    scanf("%d", &N);    while (N--)    {        scanf("%d%d", &a, &b);        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>输入中每行是一对a和b。其中会有一对是0和0标志着输入结束，且这一对不要计算。</p><h2>输出</h2><p>对于输入的每对a和b，你需要在相应的行输出a、b的和。</p><p>如第二对a和b，他们的和也输出在第二行。</p><h2>样例输入</h2><p><code>1 5</code><code>10 20</code><code>0 0</code></p><h2>样例输出</h2><p><code>6</code><code>30</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b;    while (scanf("%d%d", &a, &b), a || b)    {        printf("%d\n", a + b);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2>输入</h2><p>输入的第一行为一个整数N，接下来N行每行先输入一个整数M，然后在同一行内输入M个整数。</p><h2>输出</h2><p>对于每组输入，输出M个数的和，每组输出之间输出一个空行。</p><h2>样例输入</h2><p><code>3</code><code>4 1 2 3 4</code><code>5 1 2 3 4 5</code><code>3 1 2 3</code></p><h2>样例输出</h2><p><code>10</code><code></code><code>15</code><code></code><code>6</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a, b, N, M, num;    scanf("%d", &N);    while (N--)    {        int sum = 0;        scanf("%d", &M);        for (int i = 0; i < M; i++)        {            scanf("%d", &num);            sum += num;        }        printf("%d\n", sum);        if (N > 0)        {            printf("\n");        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-12 解密</title>
      <link href="/6-12-jie-mi/"/>
      <url>/6-12-jie-mi/</url>
      
        <content type="html"><![CDATA[<h1>习题6-12 解密</h1><h2>题目描述</h2><p>有一行电文，已按如下规律译成密码：</p><p>A--&gt;Z        a--&gt;z</p><p>B--&gt;Y        b--&gt;y</p><p>C--&gt;X        c--&gt;x</p><p>......          ......</p><p>即第一个字母变成第26个字母，第i个字母变成第（26-i+1)个字母，非字母字符不变。要求根据密码译回原文，并输出。</p><h2>输入</h2><p>输入一行密文</p><h2>输出</h2><p>解密后的原文，单独占一行。</p><h2>样例输入</h2><p><code>ZYX123zyx</code></p><h2>样例输出</h2><p><code>ABC123abc</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    char pass[100] = {};    gets(pass);    for (int i = 0; i < 100; i++)    {        if (pass[i] >= 'a' && pass[i] <= 'z')        {            pass[i] = 'a' + 'z' - pass[i];        }        else if (pass[i] >= 'A' && pass[i] <= 'Z')        {            pass[i] = 'A' + 'Z' - pass[i];        }    }    puts(pass);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-6 杨辉三角</title>
      <link href="/6-6-yang-hui-san-jiao/"/>
      <url>/6-6-yang-hui-san-jiao/</url>
      
        <content type="html"><![CDATA[<h1>习题6-6 杨辉三角</h1><h2>题目描述</h2><p>按要求输入如下格式的杨辉三角</p><p>11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1</p><p>最多输出10层</p><h2>输入</h2><p>输入只包含一个正整数n，表示将要输出的杨辉三角的层数。</p><h2>输出</h2><p>对应于该输入，请输出相应层数的杨辉三角，每一层的整数之间用一个空格隔开</p><h2>样例输入</h2><p><code>5</code></p><h2>样例输出</h2><p><code>1</code><code>1 1</code><code>1 2 1</code><code>1 3 3 1</code><code>1 4 6 4 1</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int n;    scanf("%d", &n);    int a[n][n];    if (n <= 10)    {        for (int i = 0; i < n; i++)        {            for (int j = 0; j <= i; j++)            {                if (j == 0 || j == i)                {                    a[i][j] = 1;                }                //该元素的值等于正上方和左上方元素的和                else                {                    a[i][j] = a[i - 1][j] + a[i - 1][j - 1];                }                printf("%d ", a[i][j]);            }            printf("\n");        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6-4 有序插入</title>
      <link href="/6-4-you-xu-cha-ru/"/>
      <url>/6-4-you-xu-cha-ru/</url>
      
        <content type="html"><![CDATA[<h1>习题6-4 有序插入</h1><h2>题目描述</h2><p>有一个已排好序的数组，要求输入一个数后，按原来排序的规律将它插入到数组中。</p><p>假设数组长度为10，数组中前9个数（这9个数要求从键盘上输入，输入时要满足自小到大的输入顺序）已经按从小到大进行排序。</p><p>然后再从键盘上输入一个整数，将此整数插入到前有序的9个数中，使得最终的10个数依然是从小到大有序的。</p><h2>输入</h2><p>第一行输入以空格分隔的9个整数数，要求按从小到大的顺序输入。</p><p>第二行输入一个整数</p><h2>输出</h2><p>从小到大输出这10个数，每个数一行。</p><h2>样例输入</h2><p><code>1 11 21 31 41 51 61 71 81</code><code>45</code></p><h2>样例输出</h2><p><code>1 11 21 31 41 45 51 61 71 81</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int a[10] = {0};    for (int i = 0; i < 9; i++)    {        scanf("%d", &a[i]);    }    scanf("%d", &a[9]);    //采用冒泡排序    //趟数 n - 1    for (int i = 1; i <= 9; i++)    {        //比较次数 n - i        for (int j = 0; j < 10 - i; j++)        {            if (a[j] > a[j + 1])            {                int temp = a[j];                a[j] = a[j + 1];                a[j + 1] = temp;            }        }    }    for (int i = 0; i < 10; i++)    {        printf("%d ", a[i]);    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-1 一元二次方程求根</title>
      <link href="/4-1-yi-yuan-er-ci-fang-cheng-qiu-gen/"/>
      <url>/4-1-yi-yuan-er-ci-fang-cheng-qiu-gen/</url>
      
        <content type="html"><![CDATA[<h1>例题4-1 一元二次方程求根</h1><h2>题目描述</h2><p>求一元二次方程ax2+bx+c=0的根，三个系数a, b, c由键盘输入，且a不能为0，但不保证b2-4ac&gt;0。</p><p>程序中所涉及的变量均为double类型。</p><h2>输入</h2><p>以空格分隔的一元二次方程的三个系数，双精度double类型</p><h2>输出</h2><p>分行输出两个根如下（注意末尾的换行）：</p><p>r1=第一个根</p><p>r2=第二个根</p><p>结果输出时，宽度占7位，其中小数部分2位。</p><p>如果方程无实根，输出一行如下信息（注意末尾的换行）：</p><p>No real roots!</p><h2>样例输入</h2><p><code>1 2 3</code></p><h2>样例输出</h2><p><code>No real roots!</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>#include <cmath>int main(){    double a, b, c;    double r1, r2;    scanf("%lf%lf%lf", &a, &b, &c);    if (a)    {        if (pow(b, 2) < 4 * a * c)        {            printf("No real roots!");        }        else        {            r1 = (-b + sqrt(pow(b, 2) - 4 * a * c)) / 2 * a;            r2 = (-b - sqrt(pow(b, 2) - 4 * a * c)) / 2 * a;            printf("r1=%f\nr2=%f", r1, r2);        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-10 分数序列求和</title>
      <link href="/5-10-fen-shu-xu-lie-qiu-he/"/>
      <url>/5-10-fen-shu-xu-lie-qiu-he/</url>
      
        <content type="html"><![CDATA[<h1>习题5-10 分数序列求和</h1><h2>题目描述</h2><p>有如下分数序列有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前 20 项之和</p><p>求出次数列的前20项之和。</p><p>请将结果的数据类型定义为double类型。</p><h2>输入</h2><p>无</p><h2>输出</h2><p>小数点后保留6位小数，末尾输出换行。</p><h2>样例输入</h2><p><code>无</code></p><h2>样例输出</h2><p><code>32.660261</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    //element分子，denominator分母    double denominator = 1, element = 2, temp;    double sum = 0;    for(int i = 1; i <= 20; i++)    {        sum += element / denominator;        temp = denominator;        //修改分母前，先保存分母        denominator = element;        element = temp + element;    }    printf("%.6f\n", sum);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-8 Fibonacci数列</title>
      <link href="/5-8-fibonacci-shu-lie/"/>
      <url>/5-8-fibonacci-shu-lie/</url>
      
        <content type="html"><![CDATA[<h1>例题5-8 Fibonacci数列</h1><h2>题目描述</h2><p>输入一个正整数n，求Fibonacci数列的第n个数。Fibonacci数列的特点：第1,2个数为1,1。从第3个数开始，概述是前面两个数之和。即：</p><p>要求输入的正整数n不超过50.</p><h2>输入</h2><p>一个不超过50的正整数</p><h2>输出</h2><p>Fibonacci数列的第n个数，末尾输出换行。</p><h2>样例输入</h2><p><code>20</code></p><h2>样例输出</h2><p><code>6765</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int Fibonacci(int n){    if (n == 0)    {        return 0;    }    else if (n == 1)    {        return 1;    }    else    {        return Fibonacci(n - 1) + Fibonacci(n - 2);    }}int main(){    int n;    scanf("%d", &n);    if (n <= 50)    {        printf("%d", Fibonacci(n));    }        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-7 求圆周率pi的近似值</title>
      <link href="/5-7-qiu-yuan-zhou-lu-pi-de-jin-si-zhi/"/>
      <url>/5-7-qiu-yuan-zhou-lu-pi-de-jin-si-zhi/</url>
      
        <content type="html"><![CDATA[<h1>例题5-7 求圆周率pi的近似值</h1><h2>题目描述</h2><p>用如下公式</p><p><img src="http://ppe54uht5.bkt.clouddn.com/20181015224602644.png" alt="avatar"></p><p>求圆周率PI的近似值，直到发现某一项的绝对值小于10-6为止（该项不累加）。</p><p>要求输出的结果总宽度占10位，其中小数部分为8位。</p><p>程序中使用浮点型数据时，请定义为双精度double类型。</p><p>如果需要计算绝对值，可以使用C语言数学库提供的函数fabs，如求x的绝对值，则为fabs(x).</p><h2>输入</h2><p>无</p><h2>输出</h2><p>PI=圆周率的近似值</p><p>输出的结果总宽度占10位，其中小数部分为8位。</p><p>末尾输出换行。</p><h2>样例输入</h2><p><code>无</code></p><h2>样例输出</h2><p><code>PI=3.14159065</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>#include <cmath>int main(){    double sum = 0.0;    int sign = 1;    for (double i = 1; fabs(sign / i) > pow(10, -6); i = i + 2)    {        sum += sign / i;        sign = -sign;    }    printf("PI=%10.8f", 4 * sum);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-6 矩阵输出</title>
      <link href="/5-6-ju-zhen-shu-chu/"/>
      <url>/5-6-ju-zhen-shu-chu/</url>
      
        <content type="html"><![CDATA[<h1>例题5-6 矩阵输出</h1><h2>题目描述</h2><p>输出以下4*5的矩阵</p><p>1  2  3  4  5</p><p>2  4  6  8 10</p><p>3  6  9 12 15</p><p>4  8 12 16 20</p><p>要求使用循环实现，注意每行输出5个数字，每个数字占3个字符的宽度，右对齐。</p><h2>输入</h2><p>无</p><h2>输出</h2><p>每行输出5个数字，每个数字占3个字符的宽度，右对齐。</p><h2>样例输入</h2><p><code>无</code></p><h2>样例输出</h2><p><code>1 2 3 4 5</code></p><p><code>2 4 6 8 10</code></p><p><code>3 6 9 12 15</code></p><p><code>4 8 12 16 20</code></p><h2>代码</h2><pre class="line-numbers language-language-c"><code class="language-language-c">#include <cstdio>int main(){    int n = 1;    for (int i = 0; i < 4; i++)    {        for (int j = 0; j < 5; j++)        {            printf("%3d", n++ * (i + 1));        }        n = 1;        printf("\n");    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>create</title>
      <link href="/create/"/>
      <url>/create/</url>
      
        <content type="html"><![CDATA[<h1>Hello World!</h1><h2>创建成功 :)</h2>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
